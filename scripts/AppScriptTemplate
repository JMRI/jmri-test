#! /bin/bash
#
# Script to start a JMRI @VERSION@ application
#
# This script is used for both the Linux command line and in the Mac
# OS X application bundle
#
# If you need to add any additional Java options or defines,
# include them in the JMRI_OPTIONS environment variable
#
# If your serial ports are not shown in the initial list, you
# can include them in the environment variable JMRI_SERIAL_PORTS
# separated by commas:
#    export JMRI_SERIAL_PORTS="/dev/locobuffer,/dev/cmri"
#
# You can run separate instances of the program with their
# own preferences and setup if you either
# *) Provide the name of a configuration file as the 1st argument
# or
# *) Copy and rename this script.
#
# If you rename the script to e.g. JmriNew, it will use "JmriNewConfig2.xml"
# as it's configuration file.  You can then set and save the preferences for
# the next time you rerun the script.
#
# If you are getting X11 warnings about meta keys, uncomment the next line
# xprop -root -remove _MOTIF_DEFAULT_BINDINGS
#
# For more information, please see
# http://jmri.org/help/en/html/doc/Technical/StartUpScripts.shtml
#
# $Revision$ (SVN maintains this line, do not edit please)
#

# get the script's location as an absolute path
SCRIPTDIR=$(cd "$( dirname "${0}" )" && pwd)

# define the class to be invoked
DEFAULT_APP_NAME="@NAME@"
CLASSNAME="@CLASS@"

# set DEBUG to anything to see debugging output
# DEBUG=yes

if [ -z "$OS" ]
then
    # start finding the architecture specific library directories
    OS=`uname -s`

    # normalize to match our standard names
    if [ "$OS" = "Linux" ]
    then
      OS="linux"
    fi

    if [ "$OS" = "Darwin" ]
    then
      OS="macosx"
    fi
fi

if [ "$OS" = "macosx" ]; then
    # on Mac OS X, we default to logging, since the Console app make it less visible unless you look for it
    DEBUG=yes
fi


# define JMRI_HOME if it is not defined
if [ -z "${JMRI_HOME}" ]; then
    if [ "$OS" = "macosx" ]; then
        # on OS X, the .app bundle is assumed to reside in the default JMRI_HOME
        BUNDLEDIR=$(cd "${SCRIPTDIR}/../.." && pwd)
        JMRI_HOME=$(cd "${BUNDLEDIR}/.." && pwd)
    else
        JMRI_HOME="$SCRIPTDIR"
    fi
fi

cd "${JMRI_HOME}"
[ -n "${DEBUG}" ] && echo "PWD: '${PWD}'"


# build library path
SYSLIBPATH=


LIBDIR="lib"

if [ -d "${LIBDIR}/$OS" ]
then
  SYSLIBPATH="${LIBDIR}/$OS"
fi

# one or another of these commands should return a useful value, except that sometimes
# it is spelled funny (e,g, amd64, not x86_64).

if [ -z "$ARCH" ]
then
    for cmd in "arch" "uname -i" "uname -p" "uname -m"
    do
      ARCH=`$cmd 2>/dev/null`
      if [ -n "$ARCH" ]
      then
	    # canonicalize the architecture names where possible
	    # we currently have AMD64 / X86_64
	    if [ "$ARCH" = "amd64" ]
	    then
	      ARCH="x86_64"
	    fi

            # and all the flavors of ia32 (traditional x86)
	    if [ "$ARCH" = "i686" -o "$ARCH" = "i586" -o "$ARCH" = "i486" ]
	    then
	      ARCH="i386"
	    fi

            # Now deal with ARM architecture
            if [ "$ARCH" = "armv5tel" ]
            then
              ARCH="armv5"
            fi

            if [ "$ARCH" = "armv6l" ]
            then
              # currently contains hard-float versions, may need work for others
              ARCH="armv61"
            fi

	    if [ -d "${SYSLIBPATH}/$ARCH" ]
	    then
	       SYSLIBPATH="${SYSLIBPATH}/$ARCH:$SYSLIBPATH"

	       # we're only interested in ONE of these values, so as soon as we find a supported
	       # architecture directory, continue processing and start up the program
	       break
	    fi
      fi
    done
fi


# build classpath dynamically
CP=".:classes:java/classes"
# list of jar files in home, not counting jmri.jar
LOCALJARFILES=`ls ${LIBDIR}/*.jar | grep -v jmri.jar | tr "\n" ":"`
if [ ${LOCALJARFILES} ]
then
  CP="${CP}:${LOCALJARFILES}"
fi
# add jmri.jar
CP="${CP}:jmri.jar"
# and contents of lib
CP="${CP}:`ls -m ${LIBDIR}/*.jar | tr -d ' \n' | tr ',' ':'`"

if [ -d /System/Library/Java ]
then
    CP="${CP}":/System/Library/Java
fi

[ -n "${DEBUG}" ] && echo "CLASSPATH: '${CP}'"

# configuration file name is 1st argument.
# If not provided, build config file name dynamically
if [ "$OS" = "macosx" ]; then
    # OS X can have spaces in the application name
    APPNAME=`basename -s .app "${BUNDLEDIR}"`
else
    APPNAME=`basename "$0"`
fi

[ -n "${DEBUG}" ] && echo "APPNAME: '${APPNAME}'"

# we only process a config file name when the application is
# NOT the default one this script was built for.
if [ "$APPNAME" != "$DEFAULT_APP_NAME" ]
then

    CONFIGNAME=`echo $APPNAME | tr -d '[:space:]' | tr -d '=' `

    CONFIGFILE="config=${CONFIGNAME}Config.xml"

    [ -n "${DEBUG}" ] && echo "CONFIGFILE: '${CONFIGFILE}'"
fi

# create the option string
#
# Add JVM and RMI options to user options, if any

if [ "$OS" = "macosx" ]; then
    # since bash mangles the application name and icon in $OPTIONS,
    # these are not stored in $OPTIONS
    MEMORY_OPTIONS="-Xms96m -Xmx640m"
    OS_OPTIONS="-Dapple.laf.useScreenMenuBar=true"
    OS_OPTIONS="${OS_OPTIONS} -Dcom.apple.macos.useScreenMenuBar=true"
    if [ -f "${BUNDLEDIR}/Contents/Resources/@ICON@.icns" ]; then
        APPICON="${BUNDLEDIR}/Contents/Resources/@ICON@.icns"
    else
        APPICON=`find "${BUNDLEDIR}" | grep -s -m 1 icns`
    fi
else
    MEMORY_OPTIONS="-Xms30m -Xmx200m"
fi


OPTIONS="${JMRI_OPTIONS} -noverify"
OPTIONS="${OPTIONS} -Djava.security.policy=${LIBDIR}/security.policy"
OPTIONS="${OPTIONS} -Djava.rmi.server.codebase=file:java/classes/"
OPTIONS="${OPTIONS} -Djava.library.path=.:$SYSLIBPATH:${LIBDIR}"

# memory start and max limits
OPTIONS="${OPTIONS} ${OS_OPTIONS} ${MEMORY_OPTIONS}"

# RXTX options (only works in some versions)
OPTIONS="${OPTIONS} -Dgnu.io.rxtx.NoVersionOutput=true"
[ -n "${DEBUG}" ] && echo "OPTIONS: '${OPTIONS}'"

if [ -n "$JMRI_SERIAL_PORTS" ]
then
  JMRI_SERIAL_PORTS="$JMRI_SERIAL_PORTS,"
fi

# locate alternate serial ports
ALTPORTS=`(echo "$JMRI_SERIAL_PORTS"; ls -fm /dev/ttyS* /dev/ttyUSB* /dev/ttyACM* 2>/dev/null ) | tr -d " \n" | tr "," ":"`
if [ "${ALTPORTS}" ]
then
  ALTPORTS=-Dgnu.io.rxtx.SerialPorts=${ALTPORTS}
fi
[ -n "${DEBUG}" ] && echo "ALTPORTS: '${ALTPORTS}'"


declare -a DOCK_OPTIONS
# Apple dock extensions to java get mangled by bash if included in ${OPTIONS}
if [ "$OS" = "macosx" ]
then
  DOCK_OPTIONS=(-Xdock:name="${APPNAME}" -Xdock:icon="${APPICON}")
  [ -n "${DEBUG}" ] && echo "DOCK_OPTIONS: '${DOCK_OPTIONS[@]}'"
fi


RESTART_CODE=100
EXIT_STATUS=${RESTART_CODE}
while [ "${EXIT_STATUS}" -eq "${RESTART_CODE}" ]
do

  java "${DOCK_OPTIONS[@]}" ${OPTIONS} ${ALTPORTS} -cp "${CP}" "${CLASSNAME}" ${CONFIGFILE}

  EXIT_STATUS=$?
  [ -n "${DEBUG}" ] && echo Exit Status: "${EXIT_STATUS}"
done

exit $EXIT_STATUS
