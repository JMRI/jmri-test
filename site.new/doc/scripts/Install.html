<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- $Id: Install.html,v 1.1 2004-09-02 13:28:38 jacobsen Exp $ -->
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Bob Jacobsen, LBL">
   <meta name="GENERATOR" content="Mozilla/4.75C-CCK-MCD {C-UDP; EBM-APPLE} (Macintosh; U; PPC) [Netscape]">
   <meta name="Content-Type" content="text/html; charset=iso-8859-1">
   <title>Installing JMRI Scripting</title>
</head>
<body>

<A href="../index.html">
<IMG SRC="../images/logo.gif" ALIGN=RIGHT WIDTH="160" HEIGHT="135" HSPACE="0" VSPACE="0">
</a>

<h1>Installing JMRI Scripting</h1>


Jython support is not (yet) standard in JMRI. To use it, you
have to install an extra file. 
<P>
To use scripting:
<OL>
<LI>Download the jython.jar file from 
<A HREF=""></a>
<LI>Find your JMRI installation by searching for a file 
named "jmri.jar".  In that same directory, you should find
a "lib" directory containing a file named "log4j.jar".  Move
the jython.jar file into that "lib" directory.
</OL>

To test this, start DecoderPro or PanelPro, then
select "Script Output" from the Panels menu.
The first time you run this, you'll get a number of messages
about "processing modified jar"; these can be ignored, as they are normal.
If there are no other error messages, you should now be able to use
scripting.

<H2>Writing Scripts</h2>

JMRI uses the factory-pattern extensively to get access to 
objects.  In Java this results in verbose code like
<PRE>
   Turnout t2 = InstanceManager.turnoutManagerInstance().newTurnout("LT2", "turnout 2");
   t2.SetCommandedState(Turnout.THROWN)
</PRE>

Jython simplifies that by allowing us to provide useful variables,
and by shortening certain method calls.
<P>
To get access to the SignalHead, Sensor and Turnout managers and
the CommandStation object,
several shortcut variables are defined in the .py scripts listed above:
<UL>
<LI>sensors
<LI>signals
<LI>turnouts
<LI>reporters
<LI>memories
<LI>dcc
</UL>
These can then be referenced directly in Jython as
<PRE>
   t2 = turnouts.provideTurnout("12");
   
   dcc.
</PRE>
Note that the variable t2 did not need to be declared.
<P>
Juthon provides a shortcut for parameters that have 
been defined with Java-Bean-like get and set methods:
<PRE>
   t2.SetCommandedState(Turnout.THROWN)
</PRE>
can be written as
<PRE>
   t2.commandedState = THROWN
</PRE>
where the assignment is actually invoking the set method.
Also note that THROWN was defined when running the Python script
at startup; CLOSED, ACTIVE, INACTIVE, RED, YELLOW and GREEN are
also defined.
<P>
A similar mechanism can be used to check the state of something:
<PRE>
>>> print sensors.provideSensor("3").knownState == ACTIVE 
1
>>> print sensors.provideSensor("3").knownState == INACTIVE
0
</PRE>
Note that Jython uses "1" to indicate true, and "0" to indicate
false, so sensor 3 is currently active in this example
<P>
You can also directly invoke methods, e.g. to send a DCC
packet to the rails you type:
<PRE>   
   dcc.sendPacket([0x01, 0x03, 0xbb], 4) 
</PRE>
This sends that three-byte packet four times, and then returns to the
command line.
<P>
To exit, either ^C from the command line, or use the exit
command from the menu.  

<H2>Using Python for signal logic and automation</h2>

The existing JMRI 
"<A HREF="../Automat.html">Automat</a>"
classes provide hooks for user layout automation, including signaling.
But they require that you write Java code and compile it into .class files.
<P>
The 
<A HREF="doc/jmri/jmrit/automat/JythonAutomaton.html">JythonAutomaton</a>
class is intended to make it easier to code custom layout automation, as
it will allow you to invoke a Jython script.  Once it's integrated into
the configuration process, you'll be able to code your automation in one
or more .py files, and have the program start running them at startup.

<h2>Next steps</h2>
We're just learning how to best to integrate JMRI and Python, so there
are still some basic mysteries.
<h3>Initialization and modules</h3>
The idea of Python "modules" isn't yet 
clearly understood.  There are three ways to start the program via 
a .py file:
<OL>
<LI>
<PRE>
  % ./jmrithon
  Jython 2.1 on java1.4.1_01 (JIT: null)
  Type "copyright", "credits" or "license" for more information.
  >>> import JmriDemo
</PRE>
This works, in the sense that the program starts up. But the
convenience methods are all in the JmriDemo namespace:
<PRE>
  >>> turnouts.newTurnout("LT1","")
  Traceback (innermost last):
    File "<console>", line 1, in ?
  NameError: turnouts

  >>> JmriDemo.turnouts.newTurnout("LT1","")
  jmri.jmrix.loconet.LnTurnout@36b91b
</PRE>
which makes for significantly more typing later.
And it's confusing, because depending on whether you started
JmriDemo, DecoderPro or some other application, the names will
be different.
<LI>
<PRE>
  % ./jmrithon
  >>>  execfile("JmriDemo.py")
</PRE>
or the simpler form
<PRE>
  % ./jmrithon -JmriDemo.py
</PRE>

This looks somewhat ugly, as it's not using the normal Python
modules technique.  But the convenience methods are
in the top-level name space:
<PRE>
  turnouts.newTurnout("LT1", "")
</PRE>
<BR>
We need to understand whether this is a real issue.  Most Python
programs don't use that top-level namespace, and there's probably
a good reason!
</OL>
We need to understand how the developers of Jython intended this
to be done.

<h3>Termination</h3>
Once the JMRI main thread (or Swing GUI thread?) has started, 
^D is not sufficient to exist the program.  You have to select
"Quit" from the actual file menu, or ^C the program.
<P>
It would be good to understand what's preventing the program 
from stopping when it gets the ^D.
<HR>
<BR>Site hosted by: <BR>
<A href="http://sourceforge.net"> 
<IMG src="http://sourceforge.net/sflogo.php?group_id=26788&type=1" width="88" height="31" border="0" alt="SourceForge Logo"> </A> 

<hr>
Bob Jacobsen<BR>
jake@physics.berkeley.edu

</body>
</html>
