<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<!-- Copyright Bob Jacobsen 2008 -->
<!-- $Id: Examples.shtml,v 1.1 2008-02-17 04:52:52 jacobsen Exp $ -->
<title>JMRI: Scripting Examples</title>

<!-- Style -->
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="/css/default.css" media="screen">
<link rel="stylesheet" type="text/css" href="/css/print.css" media="print">
<link rel="icon" href="/images/jmri.ico" TYPE="image/png">
<link rel="home" title="Home" href="/">
<!-- /Style -->
</head>

<body>
<!--#include virtual="/Header" -->

<!--#include virtual="Sidebar" -->
<div id="mainContent">

      <!-- Page Body -->
        <H2>
		JMRI: Scripting Examples
        </H2>



		<div class=section>

		    <div class=para>
		    
		    <p>The JMRI distributions come with a "jython" directory
		    that contains a few examples.  As of the time of writing
		    these are:</p>
		    <dl>
		    <dt>SampleSound.py<dd>A straight-forward set of statements
		    to load and play a sound.  There are some comments 
		    on how to add various options.
		    <dt>SetTurnouts.py<dd>Sets a couple of turnouts to specific
		    positions, waiting between each operation.  Because we
		    want to have the rest of the program keep running,
		    there are a few more statements involved than just
		    the commands to throw the turnouts.
		    There's also a 
		    <a href="ex_set_turnouts.shtml">separate page</a>
		    that talks more about this.
		    <dt>ListenerExample.py<dd>Example of listing to a Turnout so that
		    the script can do something every time the Turnout's state changes.
		    <dt>Sensor-sound.py<dd>An example of using a "listener"
		    to play a sound every time a particular sensor changes.
		    <dt>AutomatonExample.py<dd>A simple automation example,
		    this runs a train back and forth between two blocks.
		    <dt>OpsProgExample.py<dd>A more complicated automation example.
		    When a given sensor changes, this script will use ops-mode programming
		    (programming on the main) to change the momentum value for 
		    a particular locomotive.
		    <dt>SigletExample.py<dd>An example of driving a signal from a script.
		    <dt>JButtonExample.py<dd>This is an example of adding an object to 
		    the GUI, in this case a button.  When clicked, it doesn't really
		    do anything except print a message, but it is an example after all!
		    
		    </dl>
		    </div>

			<p>The rest of this page contains examples of specific 
			techniques.
		</div>

		<div class=section>
		    <h2>Invoking another script file from a script</h2>

		    <div class=para>
		    
		    <pre>
execfile("filename.py");
		    </pre>
		    </div>

		</div>

		<div class=section>
		    <h2>Loading a panel file from within a script</h2>

		    <div class=para>
		    
		    <pre>
jmri.InstanceManager.configureManagerInstance().load(java.io.File("filename.xml"))
		    </pre>
		    </div>

		</div>

		<div class=section>
		    <h2>Communicating between scripts</h2>

		    <div class=para>
		    All scripts share a single address space, which 
		    means that a variable like "x" refers to the same
		    location in all scripts.  This allows you to 
		    define a procedure, for example, in one script, and
		    use it elsewhere.  For example, if a "definitions.py"
		    file contained:
		    <pre>
def printStatus() :
  print "x is", x
  print "y is", y
  print "z is", z
  return

x = 0
y = 0
z = 0
		    </pre>

            Once that file has been executed, any later script can
            invoke the <code>printStatus()</code> routine whenever needed.
    	    </div>

		    <div class=para>
            You can also share variables, which allows two routines to 
            share information.  In the example above, the <code>x</code>,
            <code>y</code>, and <code>z</code> variables are available to
            anybody.
            This can lead to obscure bugs if two different routines 
            are using a variable of the same name, without realizing that
            they are sharing data with each other.  Putting your code
            into "classes" is a way to avoid that.
    	    </div>

		</div>

		<div class=section>
		    <h2>Can a script wait for more than one thing to change?</h2>

		    <div class=para>
            If your script is based on a Siglet or AbstractAutomaton
            class (e.g. if you're writing a "handle" routine", there's
            a general "waitChange" routine which waits for any of 
            several sensors to change before returning to you. Note that more 
            than one may change at the same time, so you can't assume that just 
            one has a different value! And you'll then have to check whether 
            they've become some particular state.  It's written as:

<PRE>
    self.waitChange([self.sensorA, self.sensorB, self.sensorC])
</PRE>
            where you've previously defined each of those "self.sensorA" things 
            via a line like:
<PRE>
    self.sensorA = sensors.provideSensor("21")
</PRE>
            You can then check for various combinations like:
<PRE>
   if self.sensorA.knownState == ACTIVE :
	print "The plane! The plane!"
   elif self.sensorB.knownState == INACTIVE :
	print "Would you believe a really fast bird?"
   else
	print "Nothing to see here, move along..."
</PRE>

        (I haven't actually typed these into a script & run it, so there 
        might be typos, sorry)


    	    </div>

		</div>

		<div class=section>
		    <h2>Listening to more than one Turnout</h2>

		    <div class=para>
		    JMRI objects (Turnouts, Sensors, etc) can have
		    "Listeners" attached to them. These are then notified
		    when the status of the object changes.
		    If you're using the Automat or Siglet classes, you
		    don't need to use this capability; those classes handle
		    all the creationg and registering of listeners.
		    But if you want to do something special, you may need
		    to use that capability.
		    <P>
			A single routine can listen to more than one
			Turnout, Sensor, etc.
			<P>
			If you retain a reference to your listener object, you
			can attach it to more than one object:
			<pre>
m = MyListener()
turnouts.provideTurnout("12").addPropertyChangeListener(m)
turnouts.provideTurnout("13").addPropertyChangeListener(m)
turnouts.provideTurnout("14").addPropertyChangeListener(m)
			</pre>
			<p>
			But how does the listener know what changed?
			<P>
			A listener routine looks like this:
			<pre>
class MyListener(java.beans.PropertyChangeListener):
  def propertyChange(self, event):
    print "change",event.propertyName
    print "from", event.oldValue, "to", event.newValue
    print "source systemName", event.source.systemName
    print "source userName", event.source.userName
			</pre>
			<P>
			When the listener is called, it's given an object
			(called event above) that contains the name of the
			property that changed, plus the old and
			new values of that property. 
			<P>
			You can also get a 
			reference to the original object that
			changed via "name", and then do whatever you'd like
			through that.  In the example above, you can
			retrieve the systemName, userName (or even other types
			of status).
			
		    </div>

		    <h2>Playing a sound</h2>

		    <div class=para>

			The jython/SampleSound.py file shows how to play a 
			sound within a script. Briefly, you load a sound into a variable 
            ("snd" in this case), then call "play()" to play it once, etc.
            <P>
            Note that if more than one sound is playing at a time, the
            program combines them as best it can.  Generally, it does
            a pretty good job.
            <P>
            You can combine the play() call with other logic to play a sound
            when a Sensor changes, etc.
            
            Ron McKinnon provided an example of doing this. It plays
            a railroad crossing bell when the sensor goes active.

<pre>
# It listens for changes to a sensor,
# and then plays a sound file when sensor active

import jarray
import jmri

# create the sound object by loading a file
snd = jmri.jmrit.Sound("resources/sounds/Crossing.wav")

class SensndExample(jmri.jmrit.automat.Siglet) :

	# Modify this to define all of your turnouts, sensors and 
	# signal heads.
	def defineIO(self):
		
		# get the sensor 
		self.Sen1Sensor = sensors.provideSensor("473")
				
 		# Register the inputs so setOutput will be called when needed.
 		self.setInputs(jarray.array([self.Sen1Sensor], jmri.NamedBean))

		return

	# setOutput is called when one of the inputs changes, and is
	# responsible for setting the correct output
	#
	# Modify this to do your calculation.
	def setOutput(self):
				
		if self.Sen1Sensor.knownState==ACTIVE:
			snd.play()

		return
	
# end of class definition

# start one of these up
SensndExample().start()
</pre>
		    </div>

		</div>

<!--#include virtual="/Footer" -->
</body>
</html>

