<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- $Id: Logix.shtml,v 1.4 2009-03-24 18:01:03 jacobsen Exp $ -->
<html lang="en">
<head>
 <TITLE>
      JMRI: Logix Documentation
 </TITLE>
    <META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
    <META content="David Duchamp" name=Author>
    <META name="keywords" content="java model railroad JMRI Logix">

<!-- Style -->
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="stylesheet" TYPE="text/css" HREF="/css/default.css"
	MEDIA="screen">
<LINK REL="stylesheet" TYPE="text/css" HREF="/css/print.css"
	MEDIA="print">
<LINK REL="icon" HREF="/images/jmri.ico" TYPE="image/png">
<LINK REL="home" TITLE="Home" HREF="/">
<!-- /Style -->
</HEAD>

<BODY>
<!--#include virtual="/Header" -->
  <div class="nomenu" id="mBody">
    <div id="mainContent">

      <H2> 
      JMRI: Logix Documentation
      </H2>
    
    <dd>
	<P>Logix&trade; provide a powerful capability for JMRI to monitor one  
	or more conditions on a layout, and take action when these  
	conditions change in a user-specified way.  Logix can be used  
	to control signals, crossing gates, and other types of automation 
	on the layout.  The user interface is designed to be user friendly to
	all users with basic familiarity with JMRI. A Logix provides a means
	for setting up user-specified logic in an intuitive manner, without the 
	user having to be familiar with mathematical logic.
	</p>  
	</dd>

	<dl>
	<dt class=left><a name=contents><H3>Contents</H3></a></dt>
	<dd class=top>
	<p>The documentation below describes Logix, and discusses how to set 
	them up. The documentation is divided into sections; click below for 
	easy access to a listed section. If you prefer to try before reading much,
	read <a href="#intro">Introduction to Logix and Conditionals</a>, 
	then click <a href="#start">Getting Started</a>
	and follow those instructions. Return here to read about what you did.
	<ul>
	<li><a href="#intro">Introduction to Logix and Conditionals</a>
	<li><a href="#logix">Logix</a>
	<li><a href="#conditional">Conditionals</a>
	<li><a href="#editconditional">The Edit Conditional Window</a>
	<li><a href="#start">Getting Started</a>
	<li><a href="#variable">Available State Variables</a>
	<li><a href="#action">Available Actions</a>
	<li><a href="#notes">Additional Notes</a>
	</ul>
	</dd>

	<dt class=left><a name=intro><H3>Introduction to Logix and Conditionals</H3></a></dt>
	<dd class=top>
	<p>A Logix is a small group of Conditionals focused on a single task 
	on the layout. Each Conditional may be viewed as a statement of the form:
	<p><ul>if (logical expression) then (action).</ul></p>
	<p>The "logical expression" part of a Conditional tests the state of a group
	of user-specified conditions on the layout, for example, whether certain
	turnouts are closed or thrown, or whether a block is occupied. The "action" 
	part of the Conditional specifies what action is to be 
	taken if the state of the logical expression changes.</p>
	<p>For example, one Logix with several Conditionals could control the 
	appearance of one signal head. The first Conditional could check conditions 
	for a GREEN appearance. A second Conditional could check on another allowed 
	appearance. Other Conditionals could check for other appearances. A Logix
	is flexible enough so that the signal rules of any railroad might be 
	set up, provided, of course, information needed to test the required 
	conditions is available.  So with only one Logix, a user should be able 
	to set up the required logic for setting the appearance of one signal head.	
	</p> 	
	<p>Think of a Logix as a <b>small</b> group of one or more Conditionals  
	that address a single need.  Being able to group all the Conditionals that 
	address that single need in one Logix simplifies things. Only one system name 
	is needed for all the logic addressing the task, and grouping all the logic 
	for the task in one place, makes it much easier to see how related
	logical expressions might work together and how they might affect each other. 	
	</p></dd>

    <dt class=left><a name=logix><H3>Logix</H3></a></dt>                                                                                          
	<dd class=top>
	<p>Except when it is being created or edited, 
	a Logix is "active", which means
	that the entities (turnouts, sensors, lights, etc) in logical 
	expressions of the Logix's Conditionals are being monitored. Whenever the 
	state of any of the monitored entities changes, <b>all</b> Conditionals for 
	the Logix are "calculated" in order.  
	When each Conditional is "calculated", its logical 
	expression is evaluated, and the specified action taken if conditions
	are met.</p>
	<p>A Logix does not have a state as many JMRI entities do.  A Logix does have
	the capability of being "enabled" or "disabled", however. When a Logix is 
	disabled (not enabled), the logical expressions of its Conditionals are still 
	evaluated, but the actions specified in the Conditionals are not taken.
	Whether each Logix is enabled or disabled is saved when the Logix is saved to 
	disk, so a Logix that was disabled when last stored will start up
	disabled when next loaded from the configuration file.
	When a Logix that has been disabled is enabled, the states of all its 
	Conditionals are set to UNKNOWN, and all Conditionals are calculated.
	</p>  
	<p> A Logix is defined via the Logix Table that can be accessed by 
	selecting <b>Logix Table</b> in the Tools menu. The Logix Table lists 
	all currently defined Logix by their system name and user name.  The 
	table also shows whether a Logix is "enabled". The last column of the 
	table provides an easy way to edit a Logix and its Conditionals. Simply
	clicking the <b>Edit</b> button for a Logix, will bring up the Edit Logix
	window.</p>
	<p>To create a new Logix, click the <b>Add</b> button at the bottom of the Logix 
	Table.  This will bring up a Create Logix window.  Entering a system name
	and a user name, then clicking <b>Create Logix</b>, will create the Logix, and 
	bring up the Edit Logix window. This window allows Conditionals to be created 
	and edited.  Once a Logix is created, its system name cannot be changed.
	Its user name, however, may be changed in either the Logix Table or the 
	Edit Logix window. A new user name may be any useful text, provided the new 
	user name was not previously assigned to another Logix.</p>
	<p>A Logix is named using the JMRI convention. The system name  
	for the Logix always must begin with the two letters IX and is usually 
	followed by a number selected by the user.  For example, valid  
	Logix system names include: IX1, IX34, and IX100. The user  
	name is whatever the user wants to use to identify the particular Logix, 
	for example, "Signal 5 Control". All letters in a system name must be in 
	upper case. If the user enters lower case letters, JMRI will automatically
	convert them to upper case. Also, as a convenience to the user, if the 
	entered system name does not begin with IX, the program will add IX in 
	front of what is entered.  For example, to enter a system name of IX32, 
	simply enter 32 in the system name field, and the program will do the rest.
	<p> The Edit Logix window displays the system name and user name of the 
	Logix at the top. The user name may be changed by entering/modifying the
	text in the User Name field. Next is a table of Conditionals belonging
	to the Logix. To add a new Conditional, click the <b>New Conditional</b>
	button under the Conditionals table.  This will create a new Conditional
	and open the Edit Conditional window allowing the logical expression and
	actions of the new Conditional to be defined.  An existing Conditional may be 
	edited by clicking the <b>Edit</b> button of that Conditional in the 
	table.  The user name of the Conditional may be changed in the table. The 
	user name of a Conditional may be any useful text, provided it is not the
	same as the user name of another Conditional in the same Logix.  The
	user name may be the same as the user name of a Conditional in another Logix.
	<i>When editing the user name (or any item in any JMRI table) please 
	remember to move to another cell in the table so that the program is 
	notified that you have finished your entry, otherwise the entry may not
	take effect.</i></p>
	<P>Clicking <b>Calculate</b> under the Conditionals table causes all 
	Conditionals of the Logix to be calculated. Resulting states are displayed in 
	the State column of the table. When <b>Calculate</b> is clicked, or when any
	of the monitored entities of an active Logix change state, Conditionals are 
	calculated in order of their position in the Conditionals table, starting at 
	the top and proceeding down to the last one. For many cases, 
	the order of calculation is not important. For some cases (for example, where 
	one Conditional tests the state of another, or can override the results 
	of the action taken by an earlier Conditional) the order of calculating 
	Conditionals may change the results.  So pay attention to the order of the 
	Conditionals in the Conditionals table. 
	</p>
	<p>When Conditionals are calculated
	via the <b>Calculate</b> button, no actions are taken.
	</p>
	<p>The order of Conditionals in the Conditionals table may be changed
	by clicking <b>Reorder</b> (below the Conditionals table). Clicking
	<b>Reorder</b> changes all edit buttons in the last Column of the table to 
	<b>First</b>. Select the Conditional that is to be first, and it
	is immediately moved to the top of the table. All remaining buttons change
	to <b>Next</b>. Select remaining Conditionals in desired order, until
	all buttons change back to <B>Edit</b>.
	Note that the order that
	Conditionals are listed in the Logix does not determine the order
	in which they're evaluated, nor does it force evaluation
	of one Conditional when an earlier or later one is evaluated.
	You should think of Conditionals as independent pieces of boolean
	logic that continually look for some combination of inputs to
	be true, and when that combination happens, the Conditional
	will take certain actions.
	
	<p> When <b>Done</b> is clicked at the bottom of the Edit Logix window, any 
	change in the Logix user name is checked and made. A check is made for
	inconsistencies in specifying that an entity (sensor, turnout, etc.) referenced
	in multiple state variables is not monitored as a trigger for calculation of 
	the Logix, and a warning 
	message appears if any inconsistencies are found. Then the Logix is activated, 
	the Edit Logix window is dismissed, and the user is returned to the Logix
	Table. Immediately before the Logix is activated, the state of all its 
	Conditionals is set to UNKNOWN. Immediately after activation, all 
	Conditionals are calculated.</p>
	<p>The Edit Logix window also provides a way 
	to delete a Logix if it is no longer needed. Click <b>Delete Logix</b>
	to delete the Logix being edited and all its Conditionals. </p>
	</dd>
	
	<dt class=left><a name=conditional><H3>Conditionals</H3></a>
	</dt>
	<dd class=top>
	<p>A Conditional's system name has the form IXnnnnCmm, and  
	is set automatically when the Conditional is created by the user clicking 
	<b>New Conditional</b> in the Edit Logix window. The system name of the 
	first Conditional for Logix IXnnn will always be IXnnnC1, the second 
	Conditional will have system name IXnnnC2, and so on.  The user name of a  
	Conditional is whatever the user wants to assign to identify  
	the use of the Conditional.	An entered user name must not be used by more
	than one Conditional within a given Logix, however. 
	The system name and user name are displayed
	at the top of the Edit Conditional window. The user name may be 
	entered/edited there or in the Conditionals table of the Edit Logix window.
	The user name of a Conditional may be any useful text, provided it is not the
	same as the user name of another Conditional in the same Logix.  The user 
	name may be the same as the user name of a Conditional in another Logix.
	</p>
	<p>As mentioned above, Conditionals are statements of the form:
	<p><ul>if (logical expression) then (action).</ul></p>
	<p>Therefore a Conditional has two distinct parts: its "logical expression" 
	and its "action". These are discussed separately below.
	<p>Logical expressions connect the states (true or false) of "state 
	variables". State variables test conditions on the layout or in the program, 
	for example, if a sensor is active or inactive, if a turnout is closed, if a  
	signal head is red, if the fast clock time is between 10:00  
	and 11:00, etc.  State variables are linked together in a  
	logical expression by logic operators. A list of currently available 
	state variables is provided <a href="#variable">below</a>.</p>
	<p>Logic operators currently available are NOT, AND, and AND NOT. The AND 
	operator is set up automatically by the program. For each state variable, 
	the user selects whether the NOT operator is to precede the state variable.
	If the NOT operator precedes the state variable, the true/false value of 
	the state variable is reversed. For example, if "Sensor Active CS5" is true, 
	"NOT Sensor Active CS5" will be false, and vice versa. Note that "Sensor 
	Active CS5" is sometimes not the same as "NOT Sensor Inactive CS5", because 
	Sensor CS5 may be in the UNKNOWN state.</P>	
	<p>Logical expressions read like written statements.  It is easy  
	to set up a logical expression to evaluate many situations on  
	the layout. For example, "if block 10 and block 11 are  
	occupied and turnout 20 is thrown" would be set up as:</p>
	<p><ul>Sensor Active LS1020 AND Sensor Active LS1021 AND Turnout Thrown LT20
	</ul></p>
	<p>where LS1020 is a sensor that is true when block 10 is  
	occupied (perhaps from a BDL168), sensor LS1021 is true when  
	block 11 is occupied, and Turnout Thrown LT20 is true when turnout LT20  
	is thrown.  This logical expression would calculate to true if  
	all three of the state variables are true, i.e., if block 10  
	is occupied AND block 11 is occupied AND turnout 20 is   
	thrown; otherwise it would calculate false.</p>
	<p>Actionas may be specified for each Conditional.  Each action has a 
	user selectable option of being triggered if: 1) the logical expression
	changes to true, 2) the logical expression changes to false, or 3) the
	logical expression changes. A number of action types are available.  For 
	example, Set Turnout, Set Signal Appearance, Trigger Route, etc. It is also
	possible to take no action. Available action types are described 
	<a href="#action">below</a> in detail.</p>
	
	</dd>
	
	<dt class=left><a name=editconditional><H3>The Edit Conditional Window</H3></a>
	</dt>
	<dd class=top>
	<p>The Edit Conditional window is where logical expressions are set up and 
	where actions are specified.  The Edit Conditional window is
	displayed when a Conditional is created, or when the <b>Edit</b> button of a 
	Conditional is pressed in the Edit Logix window.  The Edit Conditional 
	window displays the system name and user name of the Conditional at the 
	top. The user name may be edited by entering/modifying the text in the User 
	Name field. Any text may be used, provided it doesn't duplicate the user 
	name of another Conditional in the same Logix. Next are two sections--one 
	for the setup of a logical expression and one for set up of the two available 
	actions.</p>
	<p>The logical expression section contains a table of state variables, with 
	two buttons below. Press the <b>Add State Variable</b> to add a state 
	variable (a row in the state variables table). The first column in the 
	state variables table displays an automatic AND when appropriate. The 
	second column contains a choice box that allows the user to select the NOT
	operator as needed. The third column contains a scrolling choice box, 
	allowing selection of state variable type.  Next are three 
	columns, Name, Data 1, and Data 2, that are used to provide needed
	information for the selected variable type. When a variable type is 
	selected, N/A (for Not Applicable) is displayed in data entries that are 
	not needed to define the state variable, and a prompt message telling what
	to enter in the remaining column(s) is displayed below the table (above the
	two buttons). Available state variables are documented 
	<a href="#variable">below</a>. When a name (either system name or user
	name) is entered, it must correspond to an existing entity (sensor, turnout, 
	light, etc.). It is useful to open the Sensor Table when entering sensor 
	names, or the Turnout Table to show available turnouts, etc. The
	last column of the table (<b>Delete</b> buttons) is used to delete a state 
	variable if you decide it is no longer needed.</p>
	<p><b>Caution:</b> If you use user names to specify state variables be 
	careful when editing your user names or you may break your state variable
	definitions. The user name specified must match, character for character, 
	including blanks, the actual user name of the sensor, turnout, etc., for 
	your state variables to work. If you want to be able to freely edit your 
	user names, use system names to define your state variables.</p>
	<p>The State column of the table shows the state (true or false) of each
	state variable when it is evaluated. The state displayed includes the 
	effect of the NOT operator, if NOT is selected. For the logical expression,
	and therefore the Conditional, to calculate true, all state variables must 
	evaluate to true.</p>
	<p>The Triggers Calculation column contains checkboxes that normally are
	checked, so that a change in the state variable will trigger a calculation
	of the Logix. For those rare cases where a change in a specific entity 
	(sensor, turnout, etc.) should not trigger a calculation, you should uncheck 
	the checkbox by clicking on it. Unchecking the checkbox tells the program not
	to monitor that entity for state changes. Note that if an entity occurs in 
	more than one state variable in any Conditional of the Logix, <b>all</b>
	state variables where the specific entity occurs must
	be unchecked if a change in that entity's state is not to trigger a 
	calculation. If there are inconsistencies (checked in some places, and 
	unchecked in others) are found when the Edit Logix window is closed, a
	warning is displayed. Inconsistencies result in Logix calculation when the
	entity changes state, which could produce unexpected behavior.  So don't 
	ignore the warnings; fix the inconsistencies.</p>
	<p>At any time during the entry 
	of state variable data, the <b>Check State Variables</b> button may be 
	clicked to check the entered data and evaluate the state variables. When
	this button is pressed, the checking and evaluation proceeds until the
	check completes successfully, or an error is detected. If an error is 
	detected, the checking stops for the user to correct the error and click
	<b>Check State Variables</b> again. <i>Please remember after editing the 
	system name and data items to click a different cell in the table before 
	clicking <b>Check State Variables</b> (or <b>Update Conditional</b> at 
	the bottom of the window) so that the program is notified that you have 
	finished your entry. Otherwise your entry may not take effect, and an error 
	may be reported unnecessarily.</i></p>
	<p>The action section of the Edit Conditional window provides for specifying
	the to be taken when a Conditional is calculated. 
	To add a new action, press the "Add Action" button.
    A new "Edit Action" window will appear.
    Select an action type in the
    type box, and data items needed to completely specify the action will
    appear to the right of the type box. If you don't know what needs to be
    entered in a data field, hover your cursor over it, and a hint message
    will appear. When a name must be entered, the name must correspond to
    the system name or the user name of an existing entity (sensor, turnout,
    signal head, etc.) of the proper type. Opening the Sensor 
	Table when entering sensor names, or the Turnout Table to see available 
	turnouts, etc., may be useful. Available action types are described
	in detail <a href="#action">below</a>. If you use user names to specify 
	your actions, the same caution noted above applies. Be very careful when
	editing user names that are used to specify actions.</p>
	<p>For each action, three options are available for when to trigger the
	action: 1) On Change to True, 2) On Change to False, and 3) On Change. These
	refer to the calculated state of the Conditional, which is equal to
	the value of the logical expression as specified in the state variable table. 
	One of these options must be selected.  When done, click either
    "Update" to install your changes, 
    "Cancel" to close the window without any changes 
    or "Delete" to remove the action entirely.</P>
    
    <p>Actions are evaluated in the order listed.  To change that order, 
    click the "Reorder" button on the "Edit Conditional" window. The right-most
    buttons by the actions will then let you select the first one, next one, etc.

	<p>When the logical expression and actions have been specified, click 
	<b>Update Conditional</b> at the bottom of the window. This initiates a
	check of the logical expression (the same as done by <b>Check State 
	Variables</b>) and a check of entered data for actions. If the Conditional's
	user name has been edited, it is also checked. If an error is found, a 
	message box opens announcing the error, and the update is stopped to allow 
	the user to correct the error and click <b>Update Conditional</b> again. 
	If no error is found, the Conditional is updated
	with the entered data, the Edit Conditional window is closed, and the user
	is returned to the Edit Logix window.</p>
	<p> Two other buttons are available at the bottom of the Edit Conditional 
	window. Clicking <b>Cancel</b> will close the Edit Conditional window 
	without updating the Conditional. Clicking <b>Cancel</b> results in loss
	of any data that has been entered. The other button, <b>Delete 
	Conditional</b>, provides an easy way to delete an unneeded Conditional. 
	Click <b>Delete Conditional</b> to delete the Conditional being edited and 
	return to the Edit Logix window.</p>
	</dd>
	
	<dt class=left><a name=start><H3>Getting Started</H3></a>
	</dt>
	<dd class=top>
	    <p>Follow the following steps to create a Logix and become familiar
	    with how the Logix user interface works.
	    <ol>
		<li> Select <b>Logix Table</b> in the <b>Tools</b> menu.
		<li> Click the <b>Add</b> button at the bottom of the Logix Table.
		<li> In the Create Logix window that appears, enter 6 for system name, 
		and "test" for user name, then click <b>Create Logix</b>.
		<li> In the Edit Logix window that appears, click <b>New Conditional</b>.
		<li> In the Edit Conditional window that appears, click <b>New State
		Variable</b> to begin defining a logical expression for the Conditional.
		<li> In the new row that appears in the table, click the Variable 
		Type column entry to reveal a scrolling selection box. Select "Sensor
		Active".
		<li> Note that N/A appears in the Data 1 and Data 2 columns, and a 
		message appears asking for entry of a sensor name. Enter the name 
		(either system name or user name) of any of your existing sensors. (If 
		you don't have an existing sensor, select <b>Sensor Table</b> in the 
		<b>Tools</b> menu and create one.)
		<li> Click <b>New State Variable</b> to create another row in the table.
		Note that AND appears in the first column of the new row. Again select
		"Sensor Active" as the variable type, and enter the name of a
		different sensor (create it if needed). 
		<li> Click the State column of the second row to tell the program
		your entry is complete.  Click <b>Check State Variables</b> and 
		observe the State column.  
		<li> Click the second column entry of the second row to reveal the 
		selection box for NOT.  Select NOT, then click <b>Check State 
		Variables</b> again. Note that the State of the second state variable
		has reversed.
		<li> For Action 1 - Type, select "Set Turnout", and enter the name 
		(system name or user name) of one of your turnouts. (If you don't have 
		any turnouts, create one using the <b>Add</b> button in the Turnout 
		Table.)  Leave the Trigger Action option at "On Change to True", and the 
		Set Turnout option at "Closed".
		<li> For Action 2 - again select "Set Turnout", and enter the 
		name of the same turnout entered in Action 1. Select "On Change to 
		False" as the Trigger Option, and "Thrown" as the Set Turnout option.
		<li> Click <b>Update Turnout</b> to close the Edit Conditional window
		and return to the Edit Logix window.
		<li> Click <b>Done</b> to close the Edit Logix window and activate 
		your new Logix. Click <b>OK</b> in the reminder-to-save box that 
		appears.
    	</ol>
    	<p>You created a Logix to control the setting of a turnout 
    	according to the states of two sensors. It's as simple as that. It took 
    	you more time to read this tutorial than to create the Logix.</p>	    
	</dd>

	<dt class=left><a name=variable><H3>Available State Variables</H3></a></dt>
	<dd>
	<p>State variables that are currently available for use in Conditionals
	are listed below, along with information on each. State variables
	must always evaluate to either true or false. The condition resulting in 
	true is given for each. If the condition is not met, the state variable
	evaluates to false. When a Logix is active, the states of entities (sensor,
	turnout, light, etc.) specified in state variables in its Conditionals are 
	monitored, unless the Triggers Calculation checkbox of the state variable is
	unchecked (see <a href="#editconditional">above</a>). A calculation of all 
	Conditionals in the Logix is triggered when any monitored state changes as 
	noted below (if not obvious).
	    <ul>
		<li><b>Sensor Active</b>: Evaluates to true if the state of the
		specified sensor is active. 
		<li><b>Sensor Inactive</b>: Evaluates to true if the state of the
		specified sensor is inactive. 
		<li><b>Turnout Thrown</b>: Evaluates to true if the known state of the
		specified turnout is thrown. 
		<li><b>Turnout Closed</b>: Evaluates to true if the known state of the
		specified turnout is closed.
		<li><b>Conditional True</b>: Evaluates to true if the state of the
		specified Conditional is true. Note that because Conditional user
		names may be duplicated across different Logix, a system name must be 
		used to specify a Conditional belonging to a different Logix.
		<li><b>Conditional False</b>: Evaluates to true if the state of the
		specified Conditional is false. Note that because Conditional user
		names may be duplicated across different Logix, a system name must be 
		used to specify a Conditional belonging to a different Logix.
		<li><b>Light On</b>: Evaluates to true if the 
		specified light is on. 
		<li><b>Light Off</b>: Evaluates to true if the 
		specified light is off. 
		<li><b>Memory Equals</b>: Evaluates to true if the value saved in the
		specified memory is the same as the value specified in the state 
		variable. Calculation is triggered when the monitored memory value
		changes to or from the specified value.
		<li><b>Fast Clock Range</b>: Evaluates to true if the current fast clock
		time is between the begin time and end time specified for the range.  
		Times must be specified in hh:mm format, where hh is hours and mm is 
		minutes, relative to a 24-hour clock.  Calculation is triggered when the 
		fast clock time enters the range and when the fast clock time exits the 
		range.
		<li><b>Signal Red</b>: Evaluates to true if the appearance of the 
		specified signal head is red. Calculation is 
		triggered when the appearance change to or from red.
		<li><b>Signal Yellow</b>: Evaluates to true if the appearance of the 
		specified signal head is yellow. Calculation is 
		triggered when the appearance change to or from yellow.
		<li><b>Signal Green</b>: Evaluates to true if the appearance of the 
		specified signal head is green. Calculation is 
		triggered when the appearance change to or from green.
		<li><b>Signal Dark</b>: Evaluates to true if the appearance of the 
		specified signal head is dark. Calculation is 
		triggered when the appearance change to or from dark.
		<li><b>Signal Flashing Red</b>: Evaluates to true if the appearance of 
		the specified signal head is flashing red. Calculation 
		is triggered when the appearance change to or from flashing red.
		<li><b>Signal Flashing Yellow</b>: Evaluates to true if the appearance of 
		the specified signal head is flashing yellow. Calculation 
		is triggered when the appearance change to or from flashing yellow.
		<li><b>Signal Flashing Green</b>: Evaluates to true if the appearance of 
		the specified signal head is flashing green. Calculation 
		is triggered when the appearance change to or from flashing green.
		<li><b>Signal Lit</b>: Evaluates to true if the specified signal head is 
		lit. 
		<li><b>Signal Held</b>: Evaluates to true if the specified signal head 
		is being held. 
    	</ul>
	</dd>    
    
	<dt class=left><a name=action><H3>Available Actions</H3></a></dt>
	<dd>
	<P>Actions that are currently available for use in Conditionals are listed 
	below along with information on each:
	    <ul>
		<li><b>Set Turnout</b>: Sets the specified turnout to the chosen 
		state.  Specify the turnout to set by entering its system name or user
		name.  Specify the state to set by choosing Closed or Thrown in the 
		popup menu.		
		<li><b>Set Signal Appearance</b>: Sets the specified signal head  to 
		the chosen appearance. Specify the signal head to set by entering its 
		system name or user name.  Specify the appearance to set by choosing 
		from the popup menu.		
 		<li><b>Set Signal Held</b>: Sets the specified signal head to hold.
		Specify the signal head to hold by entering its system name or user name.  
  		<li><b>Clear Signal Held</b>: Clears the hold on the specified signal 
  		head. Specify the signal head by entering its system name or user name.  
  		<li><b>Set Signal Dark</b>: Sets the specified signal head to not lit.
		Specify the signal head by entering its system name or user name.  
  		<li><b>Set Signal Lit</b>: Sets the specified signal head to lit.
		Specify the signal head by entering its system name or user name.  
  		<li><b>Trigger Route</b>: Triggers the specified route.
		Specify the route by entering its system name or user name.  
		<li><b>Set Sensor</b>: Sets the specified sensor to the chosen 
		state.  Specify the sensor to set by entering its system name or user
		name.  Specify the state to set by choosing Active or Inactive in the 
		popup menu.		
		<li><b>Delayed Set Sensor</b>: Sets the specified sensor to the chosen 
		state after waiting for a specified number of seconds.  Specify the 
		sensor to set by entering its system name or user name. Specify the 
		state to set by choosing Active or Inactive in the popup menu. Specify 
		the number of seconds to delay before setting the sensor by entering a 
		number in the right-most field.
		<li><b>Set Light</b>: Sets the specified light to the chosen state.  
		Specify the light to set by entering its system name or user name.  
		Specify the state to set by choosing On or Off in the popup menu.		
		<li><b>Set Memory</b>: Sets the specified memory to the entered
		value.  Specify the memory to set by entering its system name or user
		name.  Specify the value to set in the memory by entering it in the 
		right-most field.
  		<li><b>Enable Logix</b>: Enables the specified Logix. Specify the Logix 
  		to enable by entering its system name or user name.  
  		<li><b>Disable Logix</b>: Disables the specified Logix. Specify the 
  		Logix to disable by entering its system name or user name.
  		<li><b>Play Sound File</b>: Plays the specified sound file. Specify the 
  		sound file to play by entering its name in the field provided. Click 
  		<b>Set</b> to bring up a file selection dialog to aid in finding the
		file. Navigate to your sound file, then click your sound file's name 
		in the dialog to copy it (including its path) to the field.
  		<li><b>Run Script</b>: Starts the specified script.
		Specify the script to start by entering its name in the field provided.
		Click <b>Set</b> to bring up a file selection dialog for finding the
		file. Navigate to your script file, then click your script file's name 
		in the dialog to copy it (including its path) to the field.
		<LI><B>Delayed Set Turnout</B>: Sets the specified turnout to the
		chosen state after waiting for a specified number of seconds. Specify
		the turnout to set by entering its name. Specify the state to set by
		choosing Closed or Thrown in the popup menu. Specify the number of
		seconds to delay before setting the turnout by entering a number in the
		right-most field. If this Conditional is already waiting to set this 
		turnout, this action is ignored, and the previous action continues as 
		originally scheduled.(see also <b>Reset Delayed Set Turnout</b> below.)</LI>
		<LI><B>Turnout Lock</B>: Locks or unlocks a turnout. Enter the
		name for the turnout, and choose the operation from the popup menu.
		Note, to control the type of turnout lock go to the <A
		HREF="TurnoutTable.shtml">Turnout Table</A> and select the Lock Mode.</LI>
		<LI><B>Reset Delayed Set Sensor</B>: Sets the specified sensor to the
		chosen state after waiting for a specified number of seconds. Specify
		the sensor to set by entering its name. Specify the state to set by
		choosing Active or Inactive in the popup menu. Specify the number of
		seconds to delay before setting the sensor by entering a number in the
		right-most field. This action is the same as <b>Delayed Set Sensor</b>, 
		except if this Conditional is already actively waiting to set the specified 
		sensor, the previous wait is cancelled, and a new wait period is started. 
		In effect, the wait time is restarted. The sensor is not set until the most 
		recent wait period expires.</LI>
		<LI><B>Cancel Sensor Timers</B>: Cancels all timers waiting to set the 
		specified sensor in all Conditionals in all Logixs. Specify the sensor by 
		entering its name. The sensor is not set; all active delayed actions for 
		setting the specified sensor are cancelled without setting the sensor.</LI>
		<LI><B>Reset Delayed Set Turnout</B>: Sets the specified turnout to the
		chosen state after waiting for a specified number of seconds. Specify
		the turnout to set by entering its name. Specify the state to set by
		choosing Closed or Thrown in the popup menu. Specify the number of
		seconds to delay before setting the turnout by entering a number in the
		right-most field. This action is the same as <b>Delayed Set Turnout</b>, 
		except if this Conditional is already actively waiting to set the specified 
		turnout, the previous wait is cancelled, and a new wait period is started. 
		In effect, the wait time is restarted. The turnout is not set until the most 
		recent wait period expires.</LI>
		<LI><B>Cancel Turnout Timers</B>: Cancels all timers waiting to set the 
		specified turnouts in all Conditionals in all Logixs. Specify the turnout by 
		entering its name. The turnout is not set; all active delayed actions for 
		setting the specified turnout are cancelled without setting the turnout.</LI>
		<LI><B>Set Fast Clock Time</B>: Sets the time on the fast clock to the entered 
		time. The time is entered as <i>hh:mm</i> where <i>hh</i> is hours and <i>mm</i> 
		is minutes on a 24-hour clock. This action sets the fast clock to the specified
		time regardless of whether the fast clock is running or stopped.</LI>
		<LI><B>Start Fast Clock</B>: Starts the JMRI fast clock running. If the fast 
		clock is already running, this action has no effect.</LI>
		<LI><B>Stop Fast Clock</B>: Pauses the JMRI fast clock. If the fast 
		clock is not running, this action has no effect.</LI>
		<LI><B>Copy Memory To Memory</B>: Copies the value of a memory variable to 
		another memory variable. Specify the memory to be copied from by entering its 
		name in the leftmost field. Specify the memory to receive the copied value by 
		entering its name in the rightmost field.</LI>
		</ul>
	</dd>    
	<dt class=left><a name=notes><H3>Additional Notes</H3></a></dt>
	<dd>
	<p> This section contains questions and answers that normally are not 
	needed by Logix users, but in some cases may be important or of 
	interest. 
	<ul>
	<p><li><b> How can an inclusive OR be done without the OR operator?</b>
	<p>To achieve "logical expression A"  OR  "logical expression B" without 
	needing an OR operator use two Conditionals--Conditional 1 would calculate 
	logical expression A, triggering the desired action if it calculated true 
	(or false); the second Conditional would begin with NOT Conditional 1 true
	(or false) as its  first state variable, then AND logical expression B. In 
	this way the second Conditional would trigger the desired action if logical  
	expression B calculated true, provided the action wasn't already  
	triggered by Conditional 1.  By simple extension of this idea, you can
	achieve OR of three or more logical expressions.  
	<p>There are also other ways of accomplishing the OR by use of multiple 
	Conditionals. The idea is that simple inclusive OR's can be accomplished 
	without complicating the Logix user interface with additional operators 
	or grouping of state variables.
	<p><li><b>Why have a "group" of Conditionals instead of just single 
	Conditionals?</b>
	<p> A group of Conditionals was chosen for several reasons, including:
	<ol>
	<p><li>Grouping Conditionals into a Logix, and focusing the Logix on one 
	task should end up being much more user friendly. Think about one Logix 
	with several Conditionals controlling one three-turnout signal head.  The 
	first Conditional could check conditions for a RED appearance, and take 
	appropriate action. The second Conditional could check on another allowed 
	appearance which, depending upon the rules of the railroad being modeled
	could depend upon the calculated state of the first Conditional.  Other 
	Conditionals would check for other appearances according to the rules of 
	the railroad. So with only one Logix, a user should be able to set up the 
	required logic for setting appearances for one signal head. Thus once the 
	sensors, turnouts, and signal heads are set up, only one new system name, 
	the system name of the Logix, need be defined and kept track of. 
	<p><li>Another reason for grouping multiple Conditionals is simpler 
	operation.  Fewer
	behind the scene listeners are needed to accomplish the same task.  Even 
	though, following the example above, the logic for each appearance of the 
	signal head (each Conditional) may depend upon a particular sensor (a 
	block occupancy for example), if the Conditionals are combined into a 
	single Logix, only _one_ listener for that sensor is required.  This is 
	simpler in implementation than having multiple listeners.
	</ol>
	<p><li><b>How is a Logix started?</b>
	<p>Start of a Logix is similar to the way a light, a route, or 
	other continuously running JMRI entity starts.  Internally a Logix has an 
	"activate" method, that is called when the Logix is created, after it  
	is edited, or when it is loaded from a configuration file.  This  
	method starts listeners for items in the state variables
	of the Logix's Conditionals.  When any of these listeners fires (indicating
	that the watched property of a state variable has changed), the Logix  
	is calculated, resulting in appropriate actions being taken, provided the 
	Logix is enabled.
	<p><li><b>What is the initial state of a Logix and its Conditionals?</b>	
	<p>When a Logix is created or edited, the initial state of each Conditional 
	is true or false as shown in the Edit Logix window.  When a Logix is loaded 
	from a configuration file, the initial state of each Conditional is UNKNOWN.
	<p>A Logix is enabled automatically when it is created.  
	A Logix may be disabled/enabled by 
	unchecking/checking the button in the Enable column in the Logix table.  
	For example, you might want to disable a Logix while you're creating
	and debugging it, until you're certain that you have it set up properly.
	A Logix may be enabled or disabled dynamically by another Logix (see allowed 
	actions <a href="#action">above</a>).
	<P>
	When JMRI stores the layout configuration in a file, e.g. a panel file, all
	Logix information, including the enabled/disabled state of the Logix, is 
	stored. When a Logix is loaded from a configuration file, it's enabled or disabled status
	is set according to what was saved in the configuration file.
	This is done so that people can disable their Logix while debugging them,
	yet still save and restore the configuration as needed. 
	<p><li><b>What happens when a JMRI program starts up or when a configuration 
	file is loaded by a JMRI program?</b>
	<p>This is a complex question that depends upon many things,
	such as, how the user has set up for turnout feedback, block detection, etc. 
	When a configuration 
	file is read, the various entities (sensors, turnouts, signal heads, etc.) 
	are loaded in an almost random order.  So it's not reasonable, for example,  
	to calculate each Logix as it is loaded, since the needed state variable 
	entities might not be present when the Logix is loaded.  And,  
	since most entities will load in UNKNOWN state, calculating a Logix 
	immediately after the entire  configuration file is loaded doesn't produce
	a clean start up either.  So when a Logix is loaded, the state of each 
	Conditional starts as UNKNOWN. Immediately after the entire configuration 
	file is loaded, all Logix are activated, and then all the Logix are 
	calculated. The state of Conditionals changes from UNKNOWN to true or false. 
	But will the calculated state of the Conditional be "correct" if one or more 
	of the state variables is evaluated from an entity in an UNKNOWN state?  For 
	example, think of a turnout in an UNKNOWN state--Turnout Thrown and 
	Turnout Closed will both evaluate to false.  As listeners continue to fire 
	for state variables, eventually every entity has its correct current state 
	and the Logix will work fine.  You can monitor this action by watching 
	states in the Sensor Table, the Turnout Table, etc. Conditions at start up 
	certainly are something to keep in mind when setting up a Logix.</p>
	<p><li><b>When should Triggers Calculation be unchecked in a state variable?</b>	
	<p>Normally Triggers Calculation should be checked in all state variables, 
	so a change in any of its state variable will trigger calculation of a Logix. 
	This results in the Logix quickly reacting to changes on the layout, and 
	maintaining the status of signals, turnouts, etc. as desired. There are 
	situations, however, where it is desirable to test the state of an entity,
	but not use it as a calculation trigger.  The following paragraphs 
	describe a couple of those situations, but there are others.</p>
	<p>Occasionally a "logic loop" can result if triggering is not 
	suppressed. For example, if the state of a turnout is tested in a state 
	variable, and the same turnout is set in an action of the same or another 
	Conditional of the same Logix, continuous triggering (a logic loop) could 
	result. The easiest way out of this dilemma is to test the turnout, without
	using it as a triggering entity. This is done by unchecking Triggers 
	Calculation	in <b>all</b> state variables where the turnout is specified.
	If the turnout is used in state variables of more than one Conditional of 
	the Logix, it must be unchecked everywhere it is used to suppress using it
	as a trigger.</p>
	<p>Another situation arises when Delayed Set Sensor action is used with
	an internal sensor to trigger a second Logix after the delay time has 
	elapsed. If the second Logix is not to be triggered before the delay time 
	elapses, all of its state variables, except for the delayed internal sensor, 
	should be unchecked. This scenario might occur, for example, if a Conditional
	turns on something as its first action, and sets a Delayed Set Sensor as 
	its second action to turn off that something after a specified time provided
	certain conditions are met.</p>
<p><li><b>What is a "logic loop" and how can it be avoided?</b>

<p>A "logic loop" results when the program appears to slow down significantly or 
lock up as multiple Logixs are continuously triggered by changing references to 
each other.  The best way to avoid a "logic loop" is to be aware of situations 
that can lead to a loop, and plan your logic to avoid such situations. </p>
<p>A "logic loop" can result within a single Logix when a state variable (sensor, 
turnout, etc.) that triggers the Logix is also changed by that same Logix.  The 
Logix editor will detect some situations that could result in a loop, and will 
issue a warning when you close the Logix. <b>Heed these warnings!</b> A warning 
doesn't mean that a loop definitely will result if you continue. The warning 
message is a "wake up call" that you should study carefully what you're doing 
to make sure a loop won't result. </p> 
<p>A more complicated situation involving two or more Logixs can also result in 
a "logic loop".  For example, if Logix 1 is triggered by sensor A, and has an 
action that changes turnout B, and Logix 2 is triggered by turnout B and changes 
sensor A, the potential for a loop exists as these Logixs trigger each other.  
You can easily extend this idea to triggering chains (loops) involving three or 
more Logixs, and even to interactions between Logixs and Routes. There is no 
test in the program to warn about loops involving multiple Logixs. (To develop 
such a test would be very difficult.)</p>

<p><li><b>What should I do if I think I have a "logic loop"?</b>

<p>When they do occur, "logic loops" can be a bit scary to trouble shoot. Your 
computer may appear to be locked up, or slowed to a crawl as the loop uses up 
most of the available computer time. Fortunately JMRI provides tools to help in 
design and debugging. Unchecking "Triggers Calculation" for a state variable 
(discussed above), can help you design around loops when you have identified the 
Logix causing the looping problem. To get around the lock up or slow down 
problem, start with all your Logixs disabled, (see below) then enable them one 
by one until you discover the loop.</p>
<p>If the panel file containing Logixs loads automatically when
the program starts up, press and release the shift key a few times rapidly as
soon as you see the small JMRI splash screen (the first thing you see during 
start up). Your panel file will be loaded with all Logixs disabled.</p>
<p>If you load your panel file manually using the Panels menu, before loading
your file, go to the <b>Debug</b> menu and select <b>Load Logixs Disabled</b>. 
After responding OK to the message, load your panel file as you normally  would. 
Your panel file will be loaded with all Logixs disabled.</p>
<p>After loading your panel file, open the Logix Table and verify that all
Logixs are disabled. If you know which Logix is causing the trouble, you
can then fix it or delete it, re-enable the other Logixs, and save your panel
file. If you don't know which Logix is causing the problem, you can enable 
your Logixs, one by one, until the loop occurs. When the loop starts, 
you know that the last Logix you enabled is at least partly responsible for
the problem. At this point you should restart the program with all Logixs 
disabled, and fix or delete the Logix you identified.</p>
<p><b>CAUTION:</b> <b>It's wise to save your panel file frequently when entering 
Logixs.</b> If a logic loop occurs, it may be difficult, if not 
impossible, to save your panel file before shutting down the program. 
Remember that a Logix is activated as soon as you click <b>Done</b> in
the Edit Logix window. Also, remember that hitting an <b>Edit</b> button
in the Logix Table deactivates the selected Logix before opening it for editing,
offering a possible way to break into a logic loop without restarting the
program.</p>
    </dd>

<!--#include virtual="/Footer" -->
</body>
</html>
