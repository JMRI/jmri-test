<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- $Id: IntroStructure.shtml,v 1.3 2009/04/26 18:53:55 jacobsen Exp $ -->
<!-- Translated by Blorec Hervé le 2011-05-06--> 
<html lang="fr">
<head>
    <TITLE>
 	JMRI: Introduction to JMRI Library Structure  
    </TITLE>
    <META content="Bob Jacobsen" name=Author>
    <meta name="keywords" content="JMRI technical code ">

    <!-- The combination of "Define" and {Header,Style, Logo and Footer} comments -->
    <!-- are an arbitrary design pattern used by the update.pl script to -->
    <!-- easily replace the common header/footer code for all the web pages -->

    <!-- delete the following 2 Defines if you want to use the default JMRI logo -->
    <!-- or change them to reflect your alternative logo -->

<!-- Style -->
  <META http-equiv=Content-Type content="text/html; charset= utf-8">
  <link rel="stylesheet" type="text/css" href="/css/default.css" media="screen">
  <link rel="stylesheet" type="text/css" href="/css/print.css" media="print">
  <link rel="icon" href="/images/jmri.ico" type="image/png">
  <link rel="home" title="Home" href="/">
<!-- /Style -->
</head>

<!--#include virtual="/Header" -->Introduction to JMRI Library Structure
<!--#include virtual="Sidebar" -->

	<div id="mainContent">

<H1>JMRI: Introduction à la Structure de la Librairie de JMRI</H1>

Parce que nous nous attendons à avoir des interfaces différentes dans le paquet jmrix, les outils JMRI ne créez pas directement 
les objets d'interface dont ils ont besoin. Plutôt, ils demandent des exemples d'interfaces. Pour les interfaces dans le package jmri, 
qui pourraient être mises en œuvre par beaucoup de types de réseaux différents, jmri.InstanceManager répond à ces demandes.

<P>
Plus d'informations sur la façon dont les choses (par exemple des objets représentant les éléments sur la mise en page)
sont nommées et
<A HREF="Names.shtml"> sont disponibles sur une page séparée </a>.

<p>
Plus précisément:

<dl>
<dt> jmri
<dd> contient des interfaces et implémentations de classe de base pour les objets communs JMRI . Ceci est l'interface de base
de la bibliothèque globale JMRI et de ses capacités. Le Code dans le paquet jmri devrait dépendre d'aucun autre code JMRI,  
mais elle peut dépendre de code externes (log4j, etc)

<dt>jmrit 
<dd> contient des outils utiles et souvent des extensions. Il peut dépendre de JMRI .* et externes. Il ne doit pas dépendre jmrix.*

 <dt>jmrix
<dd> contient le code qui est spécifique à un système externe particulier. Cela inclut les implémentations des interfaces de jmri
 qui sont spécifiques à un système, plus spécifiques au système outils (à long terme, celles-ci pourraient certainement être séparées)
jmrix peut dépendre de jmri et d'externes, mais pas de interfaces jmrit.

 <dt>util
<dd> classes des services généraux qui sont des outils _pas_ niveau de l'utilisateur.

<dt>gestionnaires 
<dd> les implémentations Résumées et par défaut des différents Gestionnaires de type JMRI, par exemple, les classes concrètes de 
la InstanceManager. Il s'agit d'un accident de l'histoire que ceux-ci aient leurs propres paquets, plutôt que d'être roulé 
dans jmri.implementations.

<dt>implémentations 
<dd>L'implémentations Abrégée et par défaut des objets jmri; pas de code système ou Swing permis ici.Ils sont dans un paquet séparé, 
plutôt que dans jmri lui-même, pour rendre le paquet jmri simple à comprendre pour les personnes qui veulent juste utiliser la bibliothèque.

<dt>applications 
<dd> contient les bases de l'application qui peut utiliser les classes jmri, jmrit, et jmrix , ainsi que toute autre chose.
En ayant cela ici, nous brisons la dépendance entre les classes et jmrix jmrit (quelqu'un doit créer les objets outil généraux 
et spécifiques au système pour une application; que la dépendance est de l'apps package)
</dl>

En gros:
<PRE>


   apps   ->   jmri

                  A  A
                 /    \
                /      \
              jmrix     jmrit


</PRE>
(Cela devrait montrer des applications en utilisant jmrit et jmrix aussi, mais c'est trop difficile à dessiner en ASCII)

<P>
L'utilisation intensive du pattern Factory via des objets que nous appelons «gestionnaire » des objets.</dl>


     
<h3>Exemple: un Aiguillage</h3>
Aiguillage implique:
<UL>
<LI> aiguillage - l'interface de base. C'est ce que vous devriez vous attendre à trouver lorsque vous écrivez votre code d'automatisation 
du réseau, c'est ce que vous obtenez lorsque vous faites une demande de la TurnoutManager, etc
<LI> AbstractTurnout - fournit pour la commodité lors de l'implémentation de l'interface de l'aiguillage pour du matériel spécifique, 
ceci offre la mise en œuvre de base .
<LI> LnTurnout - une implémentation spécifique pour les aiguillages LocoNet - connectés.
</ UL>

<P>
Pour obtenir une exemple d'Aiguillage spécifique qui représente quelque chose sur le réseau, vous faite une demande d'un TurnoutManager. 
Il s'agit également d'une interface, avec une implémentation semblable du modèle. </UL>



<!--#include virtual="/Footer" -->

	  </div><!-- closes #mainContent-->
	</div> <!-- closes #mBody-->
</body>
</html>

