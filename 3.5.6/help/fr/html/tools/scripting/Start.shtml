<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="fr">
<head>
<!-- Copyright Bob Jacobsen 2008 -->
<!-- $Id: Start.shtml,v 1.4 2010/01/12 03:06:15 bhoffman351 Exp $ -->
<!-- Translated  by Blorec Hervé le 2011-09-27-->
<title>JMRI: Getting Started with Scripting</title>

<!-- Style -->
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="/css/default.css" media="screen">
<link rel="stylesheet" type="text/css" href="/css/print.css" media="print">
<link rel="icon" href="/images/jmri.ico" TYPE="image/png">
<link rel="home" title="Home" href="/">
<!-- /Style -->
</head>

<body>
<!--#include virtual="/Header" -->

<!--#include virtual="Sidebar" -->
<div id="mainContent">

<!-- Page Body -->
<H2>
JMRI: Mise en Route avec des Scripts
</H2>

<h3>Exécuter "Bonjour le monde"</h3>
Il ya plusieurs façons d'utiliser des scripts Python avec JMRI.
Le plus simple est d'utiliser le support intégré dans les applications standards de JMRI
: PanelPro, DecoderPro, etc. Pour ce faire:
<UL>
<LI> Dans le menu "Panneaux" , sélectionnez "entrée de script". Cela vous donnera
une fenêtre où vous pourrez taper un ou plusieurs commandes à exécuter.
(Notez que cela pourrait prendre un peu de temps la première fois que vous faites cela et
que le programme trouve que c'est une bibliothèques, il sera plus rapide la prochaine fois)
Les commandes restent
dans la fenêtre, donc vous pouvez les éditer et les relancer jusqu'à ce qu'elles vous conviennent.
<LI> Dans le  menu "Panneaux" , sélectionnez "sortie du script". Cela crée une
fenêtre qui montre la sortie de la commandes de script que vous émettez.
<LI> Pour le voir en fonctionnement, tapez
<PRE>
print "Bonjour le monde"
</PRE>
dans la fenêtre de saisie et cliquez sur "Exécuter". Vous devriez voir immédiatement la fenêtre sortie du script
:
<pre>
print "Bonjour le monde"
Bonjour le monde
</pre>
<LI>Python évalue également les expressions, etc. Retirez le
contenu de la fenêtre d'entrée (le sélectionner et appuyez sur supprimer), et entre
<pre>
print 1+2
</pre>
puis cliquez sur exécuter.
La fenêtre de sortie doit alors montrer quelque chose comme
<pre>
print 1+2
3
</pre>
</ul>

<h3>Commandes Simples réseau</h3>

<pre>

>>> lt1 = turnouts.provideTurnout("1")

>>> lt1.setCommandedState CLOSED(DIRECT)

>>> print lt1.commandedState
2

>>> lt1.commandedState = THROWN (DÉVIÉ)

>>> print lt1.commandedState
4

>>> turnouts.provideTurnout("1").getCommandedState()
1

</PRE>

Notez que ce n'est qu'en exécutant une version complète de l'application JMRI;
toutes les fenêtres et les menus sont présentés de la même façon, la configuration est
fait par le panneau des préférences, etc. Que la connexion Jython ajoute une
ligne de commande à partir de laquelle vous pouvez manipuler directement les choses.

<BR/> Cela montre aussi certaines des simplifications que
Jython et le langage Python apporte à l'usage du code JMRI . La
fonction  membre de Java:
<PRE>
turnout.SetCommandedState (jmri.Turnout.CLOSED);
</PRE>
peut aussi être exprimée en Jython:
<PRE>
turnout.commandedState = CLOSEDDIRECT
</PRE>
<BR/>
Il en résulte un code beaucoup plus facile à lire.
<P>
Il ya beaucoup de livres utiles et de didacticiels Python
 en ligne.
Pour plus d'informations sur le langage Jython et en
relations avec Java, la meilleure référence est le
<A HREF="http://www.oreilly.com/catalog/jythoness/"> Jython Essentials </a>
livre publié par O'Reilly. Le
<A HREF="http://www.jython.org/"> site web jython.org  </a> est également très utile.


<h3>Accès aux  JMRI </h3>

JMRI utilise longuement le modèle-type pour obtenir l'accès aux
objets. En Java il en résulte un code verbeux comme
a
<PRE>
    L'aiguillage t2 = InstanceManager.turnoutManagerInstance () newTurnout ("LT2», «participation 2.");
    t2.SetCommandedState (Turnout.THROWN)
</PRE>
Jython simplifie ceci, en nous permettant de fournir des variables utiles,
et par le raccourcissement de certaine méthode d'appels
<P>
Pour avoir accès à des gestionnaires SignalHead, capteur et aiguillage et de
l'objet CommandStation,
 plusieurs variables raccourcies sont définis:
<UL>
a
<LI> capteurs
<LI> aiguillages
<LI>lumières
<LI> Signaux (SignalHeads)
<li> mâts (SignalMasts)
<LI>itinéraires 
<li> Cantons
<LI> journals
a
<LI> mémoires 
<LI> gestionnaire d'alimentation
<LI> programmateurs
<LI> DCC (station de commande digitale)
<li> arrêt (gestionnaire d'arrêt en cours)
<li> audio/ 
</UL>
Ceux-ci peuvent ensuite être référencées directement dans Jython comme
a
<PRE>
    t2 = turnouts.provideTurnout («12»);
   
    dcc.sendPacket (new byte [] {0x12, 0x32, 0x4E}, 5)
</PRE>
Notez que le T2 variable n'a pas besoin d'être déclarée.
<P>
Jython fournit un raccourci pour les paramètres qui ont
été définies avec Java-Bean-like méthodes get et set:
<PRE>
    t2.SetCommandedState (Turnout.THROWN)
< PRE>
peut être écrite comme
<PRE>
    t2.commandedState = THROWN (DEVIE)
</PRE>
Où l'attribution invoque en réalité la méthode d'ensemble.
Notez également que DEVIE a été défini lors de l'exécution du script Python
au démarrage, DIRECT, ACTIF, INACTIF, ROUGE, JAUNE et VERT sont
également défini. (Les raccourcis sont tous définis dans un
fichier appelé "jmri_defaults.py" que vous pouvez trouver dans le
répertoire  «jython" de la distribution)
<P>
Un mécanisme similaire peut être utilisé pour vérifier l'état de chose:
<PRE>
>> Sensors.provideSensor> print ("3"). KnownState == ACTIF
1
> Sensors.provideSensor>> print ("3"). KnownState == INACTIF
0
a
</ PRE>
Notez que Jython utilise des «1» pour indiquer vrai, et «0» pour indiquer
faux, de sorte que capteur 3 est actuellement actif dans cet exemple. Vous pouvez également
utiliser les symboles «true» et «false», respectivement.
<P>
Vous pouvez appeler directement des méthodes plus compliquées, par exemple envoyer un paquet DCC
sur les rails, vous tapez:
<PRE>
    dcc.sendPacket ([0x01, 0x03, 0xbb], 4)
<PRE>
Cela envoie ce paquet de trois octets quatre fois, puis retourne à la
ligne de commande.

<h3>Les fichiers de script, les auditeurs et les classes </h3>

Scripting ne serait pas très intéressant si vous aviez à
taper les commandes à chaque fois. Ainsi, vous pouvez mettre des scripts dans un
fichier texte et de les exécuter en sélectionnant l'élément de menu "Exécuter le script ..." ,
ou en utilisant les "Préférences avancées" pour exécuter le fichier script et
le programme commence.
<P>
Bien que les énoncées ci-dessus que nous avons montrées étaient si rapides que vous ne pouviez pas
les voir, le reste du programme a été en attente pendant que vous exécutez ces échantillons.
Ce n'est pas un problème pour un couple de déclarations, ou pour un fichier de script qui
n'a tout simplement que peu de choses (peut-être fixer un couple d'aiguillage, etc) et
quitter. Mais vous voudrez peut-être que les choses se passent sur une plus longue période,
ou peut-être même attendre que quelque chose se passe sur le réseau avant que certaines
partie de votre script ne s'exécutent. Par exemple, vous voudrez peut-être inverser une
locomotive lorsque certaines capteur indiquent qu'il a atteint la fin de la voie.
<P>
Il y a deux façons de faire cela. D'abord, votre script peut
définir un «auditeur», et l'attacher à un capteur particulier, l'aiguillage , etc
Un auditeur est une petite sous-routine qui est appelée quand tout ce qui lui est attaché 
a un changement d'état. Par exemple, un sous-programme auditeur attaché à un
aiguillage particulier est appelé lorsque l'aiguillage va de dévié à direct, ou de
direct à dévié. La sous-routine peut alors regarder autour, et décider que
faire, et d'exécuter les commandes nécessaires. Lorsque les sous-routines retournent,
le reste du programme se poursuit ensuite jusqu'à ce que l'auditeur a un nouveau le changement d'état de l'objet
, alors le processus se répète.
<P>
Pour les choses plus compliquées, où vous voulez vraiment que votre code de script
soit autonome dans le programme, vous définissez une «classe» qui fait
ce que vous voulez. Dans la forme courte, cela vous donne un moyen d'avoir une exécution de code indépendante
 à l'intérieur du programme. Mais ne vous souciez pas de cela jusqu'à ce que vous ayez
eu plus d'expérience avec les scripts.



<!--#include virtual="/Footer" -->
</body>
</html>
