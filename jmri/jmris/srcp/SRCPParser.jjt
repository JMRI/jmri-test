/* This is a parser grammar for the SRCP protocol written for code generation
with javacc */

options {
  STATIC=false;
  MULTI=true;
  VISITOR=true;
}

PARSER_BEGIN(SRCPParser)

package jmri.jmris.srcp.parser;

/* 
 * This file defines a JavaTree/JavaCC parser implementation for
 * the SRCP protocol.
 * 
 * @author Paul Bender Copyright (C) 2010
 * @version $Revision: 1.4 $
 */

// This is generated code.  DO NOT ATTEMPT TO FIX ANY FINDBUGS WARNINGS
@edu.umd.cs.findbugs.annotations.SuppressWarnings(value="NM_METHOD_NAMING_CONVENTION")

public class SRCPParser {
  
   static org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(SRCPParser.class.getName());

  }

PARSER_END(SRCPParser)

// The Tokenizer specification begins here:
SKIP :
{
    <RETURN: "\r">
  | <NEWLINE: "\n">
  | <SPACE: " ">
  
}

TOKEN :
{
  < ADDR: ( ["0"-"9"] )+ >
| < JMRITURNOUT: ["a"-"z","A"-"Z"] "T" (["0"-"9"])+ >
| < JMRISENSOR: ["a"-"z","A"-"Z"] "S" (["0"-"9"])+ >
| < JMRILIGHT: ["a"-"z","A"-"Z"] "L" (["0"-"9"])+ >
| < NONZEROBUS: ["1"-"9"](["0"-"9"])* >
| < ONOFF: (<ON>|<OFF>) >
| < #ON: <O><N>> 
| < #OFF: <O>(<F>){2} >
| < PROTOCOL: (<A>|<F>|<L>|<P>|<S>|<N>|<M>|<Z>) >
| < DRIVEMODE: ("="|"0"|"1"|"2") >
| < JULDATE: (["1"-"9"]){2,4}["0"-"3"]["0"-"9"]["0"-"9"]>
| < HOUR: (["0"-"2"])?["0"-"9"]>
| < MINSEC: ["0"-"5"]["0"-"9"]>
| < DELAY: ("-")?(["0"-"9"])+>
//| < COMMENT: (~["\n"])+ >
| < EOL :(["\n","\r"]){2} >
// Device types
| < FB: <F><B> >
| < GA: <G><A> >
| < GL: <G><L> >
| < GM: <G><M> >
| < SM: <S><M> >
| < LOCK: <L><O><C><K> >
| < TIME: <T><I><M><E>>
| < POWER: <P><O><W><E><R>>
| < SESSION: <S><E><S><S><I><O><N>>
| < DESCRIPTION: <D><E><S><C><I><P><T><I><O><N> >
| < SERVER: <S><E><R><V><E><R>>

// commands 
| < GET: <G><E><T> >
| < SET: <S><E><T> >
| < CHECK: <C><H><E><C><K> >
| < INIT: <I><N><I><T> >
| < TERM: <T><E><R><M> >
| < WAIT: <W><A><I><T> >
| < VERIFY: <V><E><R><I><F><Y>>
| < RESET: <R><E><S><E><T>>

| <#A:["a","A"]>
| <#B:["b","B"]>
| <#C:["c","C"]>
| <#D:["d","D"]>
| <#E:["e","E"]>
| <#F:["f","F"]>
| <#G:["g","G"]>
| <#H:["h","H"]>
| <#I:["i","I"]>
| <#K:["k","K"]>
| <#L:["L","L"]>
| <#M:["m","M"]>
| <#N:["n","N"]>
| <#O:["o","O"]>
| <#P:["p","P"]>
| <#R:["r","R"]>
| <#S:["s","S"]>
| <#T:["t","T"]>
| <#W:["w","W"]>
| <#V:["v","V"]>
| <#Y:["y","Y"]>
| <#Z:["z","Z"]>
}

// Lexical specifications begin here

SimpleNode command():{}
{
  // This is a simple list of the possible commands.  
  // They are broken down further below.
  ( LOOKAHEAD(4) get() | set() | check() | wait_cmd() | init() |
                 term() | reset() | verify() )  <EOL>
  {
    log.debug("Command Production");
    return jjtThis;
  }
}

void bus():{Token t;}
{
  t=<ADDR>
  {
    log.debug("BUS Production " + t.image);
    jjtThis.jjtSetValue(t.image);
    //return jjtThis;
  }
}

SimpleNode address():{Token t;}
{
  t=<ADDR>
  {
    log.debug("Address Production "+ t.image);
    jjtThis.jjtSetValue(t.image);
    return jjtThis;
  }
}

SimpleNode port():{Token t;}
{
  t=<ADDR>
  {
    log.debug("PORT Production " +t.image);
    jjtThis.jjtSetValue(t.image);
    return jjtThis;
  }
}

SimpleNode devicegroup():{}
{
  ( <FB> | <GA> | <GL> | <SM> | <TIME> | <SESSION> | <SERVER> | 
    <LOCK> | <DESCRIPTION> )
  {
    log.debug("DeviceGroup Production");
    return jjtThis;
  }
}

SimpleNode get():{}
{
  <GET> bus() ( fb() address() | 
                ga() address() port() | 
                gl() address() | 
                sm() address() | 
                time() | 
                power() | 
                server() | 
                session () | 
                lock() devicegroup() address() | 
                description() [ devicegroup() address() ] )

  {
     log.debug("GET Production");
     return jjtThis;
  }
}

SimpleNode set():{}
{
  <SET> bus() ( gl() | 
                sm() | 
                ga() address() port() zeroone() delay() | 
                fb() | 
                time() | 
                power() onoff() | 
                lock() )
  {
    log.debug("SET Production");
    return jjtThis;
  }
}

SimpleNode term():{}
{
  <TERM> bus()  ( fb() gl() | sm() | power() | server() | lock() )
  {return jjtThis;}
}

SimpleNode check():{}
{
  <CHECK> bus() ( gl() | sm() | ga() <ADDR> <ADDR> <ADDR> <DELAY> | 
                 fb() | time() | power() onoff() | lock() )
  {
    log.debug("Check Production");
    return jjtThis;
  }
}

SimpleNode wait_cmd():{}
{
  <WAIT> bus() ( fb() | time() )

  {
     log.debug("WAIT Production");
     return jjtThis;
  }
}

SimpleNode init():{}
{
  <INIT> bus() ( fb() | ga() | gl() | sm() | time() | power() )
  {
     log.debug("INIT Production");
     return jjtThis;
  }
}

SimpleNode reset():{}
{
  <RESET> bus() <SERVER>
  {
     log.debug("RESET Production");
     return jjtThis;
  }
}

SimpleNode verify():{}
{
  <VERIFY> bus() sm()
  {
     log.debug("RESET Production");
     return jjtThis;
  }
}

SimpleNode gl():{}
{
  <GL>
  {return jjtThis;}
}

SimpleNode sm():{}
{
  <SM>
  {return jjtThis;}
}

SimpleNode ga():{Token t;}
{
  t=<GA>
  { 
    jjtThis.jjtSetValue(t.image);
    return jjtThis;
  }
}

SimpleNode fb():{}
{
  <FB>
  {return jjtThis;}
}

SimpleNode time():{Token t;}
{
  t=<TIME> 
  {
    jjtThis.jjtSetValue(t.image);
    return jjtThis;
  }
}

SimpleNode power():{Token t;}
{
  t=<POWER> 
  {
    jjtThis.jjtSetValue(t.image);
    return jjtThis;
  }
}

SimpleNode server():{Token t;}
{
  t=<SERVER> 
  {
    jjtThis.jjtSetValue(t.image);
    return jjtThis;
  }
}

SimpleNode session():{Token t;}
{
  t=<SESSION> 
  {
    jjtThis.jjtSetValue(t.image);
    return jjtThis;
  }
}

SimpleNode lock():{Token t;}
{
  t=<LOCK> 
  {
    jjtThis.jjtSetValue(t.image);
    return jjtThis;
  }
}

SimpleNode description():{Token t;}
{
  t=<DESCRIPTION> 
  {
    jjtThis.jjtSetValue(t.image);
    return jjtThis;
  }
}

SimpleNode comment():{}
{
  //<COMMENT>
  {return jjtThis;}
}

SimpleNode onoff():{Token t;}
{
  t=<ONOFF>
  {
     log.debug("OnOff Production " +t.image);
     jjtThis.jjtSetValue(t.image);
     return jjtThis;
  }
}

SimpleNode zeroone():{}
{
  <ADDR>
  {return jjtThis;}
}

SimpleNode delay():{}
{
  <DELAY>
  {return jjtThis;}
}

