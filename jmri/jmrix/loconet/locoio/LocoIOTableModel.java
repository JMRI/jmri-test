// LocoIOTableModel.javapackage jmri.jmrix.loconet.locoio;import java.awt.event.*;import java.beans.*;import javax.swing.*;import jmri.jmrix.loconet.*;/** * Configurer for LocoIO hardware. *<P> * The basic logic to display buttons * is described in Chapter 7 of "Core Swing Advanced Programming". * <P> * Note that the "mode" CV in the LocoIO doesn't fully specify the * operation being done.  For example, 0x80 is both turnout closed and * turnout high; the difference is in the address field.  We read and * write mode _last_ to handle this. * <P> * @author			Bob Jacobsen   Copyright (C) 2001 * @version			$Id: LocoIOTableModel.java,v 1.2 2002-03-02 19:55:57 jacobsen Exp $ */public class LocoIOTableModel extends javax.swing.table.AbstractTableModel            implements LocoNetListener {    /**     * Address of this device     */    int unitAddress;    public void setUnitAddress(int unit) {        unitAddress = unit;        System.out.println("modified address "+Integer.toHexString(unit));    }    /**     * Define the number of rows in the table, which is also     * the number of "channels" in a signel LocoIO unit     */	private int _numRows = 16;	/**     * Define the contents of the individual columns     */	public static final int PINCOLUMN   	= 0;  // pin number	public static final int ONMODECOLUMN   = 1;  // what makes this happen?	public static final int ADDRCOLUMN 	= 2;  // what address is involved?	public static final int CAPTURECOLUMN 	= 3;  // "capture" button	public static final int READCOLUMN  	= 4;  // "read" button	public static final int WRITECOLUMN 	= 5;  // "write" button	public static final int HIGHESTCOLUMN 	= WRITECOLUMN+1;	// not currently active, i.e. reserved for the future	public static final int DOMODECOLUMN   = -1;  // what does it do?	public static final int SETCOLUMN  	= -2;  // open/closed, on/off	// store the modes	Object[] addr = new Object[_numRows];	Object[] set  = new Object[_numRows];	Object[] onMode = {"<none>", "<none>", "<none>", "<none>", "<none>", "<none>", "<none>", "<none>",					 "<none>", "<none>", "<none>", "<none>", "<none>", "<none>", "<none>", "<none>"};	Object[] doMode = {"<none>", "<none>", "<none>", "<none>", "<none>", "<none>", "<none>", "<none>",					 "<none>", "<none>", "<none>", "<none>", "<none>", "<none>", "<none>", "<none>"};    /**     * The addr field (for the address info used in each LocoIO channel)     * is stored as a string.  This converts it to an integer.     * @param row     * @return integer value of addr[row]     */    int addrFieldAsInt(int row) {        return Integer.valueOf((String)addr[row],16).intValue();    }    /**     * Code for read activity needed.  See states     * NONE, READMODE, READINGMODE,     * READADDRLOW, READINGADDRLOW,     * READADDRHIGH, READINGADDRHIGH     */    int[] needRead = new int[_numRows];    protected final int NONE = 0;    protected final int READADDRLOW = 1;    protected final int READINGADDRLOW = 2;    protected final int READADDRHIGH = 3;    protected final int READINGADDRHIGH = 4;    protected final int READMODE = 5;    protected final int READINGMODE = 6;    protected final int READ = READADDRLOW;    /**     * Code for write activity needed.  See states     * NONE, WRITEMODE, WRITINGMODE,     * WRITEADDRLOW, WRITINGADDRLOW,     * WRITEADDRHIGH, WRITINGADDRHIGH     */    int[] needWrite = new int[_numRows];    protected final int WRITEADDRLOW = 11;    protected final int WRITINGADDRLOW = 12;    protected final int WRITEADDRHIGH = 13;    protected final int WRITINGADDRHIGH = 14;    protected final int WRITEMODE = 15;    protected final int WRITINGMODE = 16;    protected final int WRITE = WRITEADDRLOW;    /**     * Primary constructor.  Initializes all the arrays.     * @param addr Address for this LocoIO unit.  Provided here,     * but may also be changed later with setUnitAddress.     */	public LocoIOTableModel(int unitAddr) {		super();        unitAddress=unitAddr;        for (int i=0; i<_numRows; i++) {            onMode[i] = "<none>";            doMode[i] = "<none>";            addr[i]="0";            needRead[i] = NONE;            needWrite[i] = NONE;        }        // for now, we're always listening to LocoNet		LnTrafficController.instance().addLocoNetListener(~0, this);	}	// basic methods for AbstractTableModel implementation	public int getRowCount() { return _numRows; }	public int getColumnCount( ){ return HIGHESTCOLUMN;}	public String getColumnName(int col) {		switch (col) {			case PINCOLUMN: return "Pin";			case ONMODECOLUMN: return "Action";			case DOMODECOLUMN: return "Then do";			case ADDRCOLUMN: return "Hex Address";			case SETCOLUMN: return "Set to";			case CAPTURECOLUMN: return "";			case READCOLUMN: return "";			case WRITECOLUMN: return "";			default: return "unknown";		}	}	public Class getColumnClass(int col) {		switch (col) {			case PINCOLUMN: return String.class;			case ONMODECOLUMN: return String.class;			case DOMODECOLUMN: return String.class;			case ADDRCOLUMN: return String.class;			case SETCOLUMN: return String.class;			case CAPTURECOLUMN: return JButton.class;			case READCOLUMN: return JButton.class;			case WRITECOLUMN: return JButton.class;			default: return null;		}	}	public boolean isCellEditable(int row, int col) {		switch (col) {			case PINCOLUMN: return false;			case DOMODECOLUMN: return true;			case ONMODECOLUMN: return true;			case SETCOLUMN: return true;			case ADDRCOLUMN: return true;			case CAPTURECOLUMN: return true;			case READCOLUMN: return true;			case WRITECOLUMN: return true;			default: return false;		}	}	public Object getValueAt(int row, int col) {		switch (col) {			case PINCOLUMN:				return Integer.toString(row*2+1);  // 1 through 33 by 2			case ONMODECOLUMN:				return onMode[row];			case DOMODECOLUMN:				return doMode[row];			case ADDRCOLUMN:				return addr[row];			case SETCOLUMN:				return set[row];			case CAPTURECOLUMN:				return "Capture";			case READCOLUMN:				return "Read";			case WRITECOLUMN:				return "Write";			default: return "unknown";		}	}	public int getPreferredWidth(int col) {		switch (col) {			case PINCOLUMN:				return  new JLabel(" 31 ").getPreferredSize().width;			case ONMODECOLUMN:				return  new JLabel("Turnout closed status message").getPreferredSize().width;			case DOMODECOLUMN:				return  new JLabel("Send throw turnout command").getPreferredSize().width;			case ADDRCOLUMN:				return  new JLabel(" Address ").getPreferredSize().width;			case SETCOLUMN:				return  new JLabel(" <unknown> ").getPreferredSize().width;			case CAPTURECOLUMN:			case READCOLUMN:			case WRITECOLUMN:				return new JButton("Capture").getPreferredSize().width;			default: return new JLabel(" <unknown> ").getPreferredSize().width;		}	}	public void setValueAt(Object value, int row, int col) {		if (col == ONMODECOLUMN) {			if (isValidOnValue(value)) {				onMode[row] = value;                // have to handle two cases specially:                if (value.equals(validOnModes[0])) {                    // turnout closed - force address                    addr[row] = Integer.toHexString(addrFieldAsInt(row)|(LnConstants.OPC_SW_REQ_DIR*256));                } else if (value.equals(validOnModes[1])) {                    // turnout open - force address                    addr[row] = Integer.toHexString(addrFieldAsInt(row)&~(LnConstants.OPC_SW_REQ_DIR*256));                }				fireTableRowsUpdated(row,row);			}		} else if (col == DOMODECOLUMN) {			if (isValidDoValue(value)) {				doMode[row] = value;				fireTableRowsUpdated(row,row);			}		} else if (col == ADDRCOLUMN) {			addr[row] = value;            // have to handle two cases specially:            if (onMode[row].equals(validOnModes[0]) || onMode[row].equals(validOnModes[1]))                // turnout closed, turnout thrown - update from address                if ( (addrFieldAsInt(row)&(LnConstants.OPC_SW_REQ_DIR*256)) !=0) {                    // closed                    onMode[row] = validOnModes[0];                } else {                    // thrown                    onMode[row] = validOnModes[1];                }            fireTableRowsUpdated(row,row);		} else if (col == SETCOLUMN) {			set[row] = value;		} else if (col == CAPTURECOLUMN) {			System.out.println("capture from "+row+","+col);		} else if (col == READCOLUMN) {			// start a read operation            needRead[row] = READ;            issueNextOperation();		} else if (col == WRITECOLUMN) {			// start a read operation            needWrite[row] = WRITE;            issueNextOperation();		}	}    protected int highPart(int value) {        return value/256;    }    protected int lowPart(int value) {        return value-256*highPart(value);    }	protected boolean isValidOnValue(Object value) {		if (value instanceof String) {			String sValue = (String) value;			for (int i=0; i<validOnModes.length; i++) {				if (sValue.equals(validOnModes[i])) return true;			}		}		return false;	}	public static String[] getValidOnModes() { return validOnModes; }	static String[] validOnModes = {							"Turnout closed command", "Turnout thrown command",                            "Toggle switch",							"Pushbutton active low", "Pushbutton active high",							"Status message"};    static int[] codeForMode = {0x80, 0x80, 0x0F, 0x2F, 0x6F, 0xC0 };    int codeFromModeString(String mode) {        for (int i=0; i<codeForMode.length; i++)            if (mode.equals(validOnModes[i])) return codeForMode[i];        return -1;    }    /**     * Convert a configuration cv and two-byte address value to     * a mode string.     * @param cv The configuration CV from the LocoIO module     * @param addr  The two-byte address from the LocoIO module     * @return     */    String modeFromValues(int cv, int addr) {        // have to handle "Turnout closed" and "Turnout thrown" with ugly code        // which assumes a particular array layout.  Note that        // our only hope of keeping this consistent is the JUnit tests        if (cv==0x80) {            if ( ((LnConstants.OPC_SW_REQ_DIR*256)&addr) !=0 ) {                // closed                return validOnModes[0];            } else {                // thrown                return validOnModes[1];            }        }        for (int i=0; i<codeForMode.length; i++) {            if (cv==codeForMode[i]) return validOnModes[i];        }        return "";    }	protected boolean isValidDoValue(Object value) {		if (value instanceof String) {			String sValue = (String) value;			for (int i=0; i<validDoModes.length; i++) {				if (sValue.equals(validDoModes[i])) return true;			}		}		return false;	}	public static String[] getValidDoModes() { return validDoModes; }	static String[] validDoModes = {"Output lead",									"Send close turnout command",									"Send throw turnout command" };	public void dispose() {		if (log.isDebugEnabled()) log.debug("dispose");		// null references, so that they can be gc'd even if this isn't.		addr = null;		set = null;		onMode = null;		doMode = null;	}    int lastOpCv = -1;    /**     * Listen to the LocoNet.     * We're listening for incoming OPC_XFR messages, which might     * be part of a read or write sequence.  We're also     * _sometimes_ listening for commands as part of a "capture"     * operation.     *<P>     * The incoming LocoNet OPC_PEER_XFR messages don't retain any information     * about the CV number or whether it was a read or write operation.     * We store the data regardless of whether it was read or write, but     * we need to remember the cv number in the lastOpCv member.     *<P>     * @param m Incoming message     */	public void message(LocoNetMessage m) {        // sort out the opCode        int opCode = m.getOpCode();        switch (opCode) {            case LnConstants.OPC_PEER_XFER:                // could be read or write operation                // check that src_low_address is our unit, and                // dst is our 0x0150                int src = m.getElement(2);                int dst = m.getElement(3)+m.getElement(4)*256;                if (dst==0x0150 && src==lowPart(unitAddress)) {                    // yes, get data and store                    if (lastOpCv<0 || lastOpCv>50)                        log.error("last CV recorded is invalid: "+lastOpCv);                    int data = m.getElement(14);                    int channel = (lastOpCv/3)-1;                    if (channel<0) log.warn("channel is less than zero");                    int type = lastOpCv - (channel*3+3);                        // type = 0 for Mode, 1 for low addr, 2 for high addr                    if (type==0) {                        // mode                        onMode[channel] = modeFromValues(data, addrFieldAsInt(channel));                    } else if (type==1) {                        // low addr - can't entirely replace anything that's there,                        // as this happens on write, and high part not written yet                        int oldAddr = addrFieldAsInt(channel);                        int newAddr = highPart(oldAddr)*256+data;                        addr[channel]=Integer.toHexString(newAddr);                    } else {                        // high addr                        int oldAddr = addrFieldAsInt(channel);                        int newAddr = lowPart(oldAddr)+256*data;                        addr[channel]=Integer.toHexString(newAddr);                    }                    // check for anything else to do                    issueNextOperation();                    return;                } else return;            // capture processing goes here            default:                // we ignore the default        }    }    /**     * Look through the table to find the next thing that     * needs to be read.     */    protected void issueNextOperation() {        // find the first item that needs to be read        for (int i=0; i<_numRows; i++) {            if (needRead[i]!=NONE) {                // yes, needs read.  Find what kind                switch (needRead[i]) {                case READADDRLOW:                    // set new state, send read, then done                    needRead[i] = READINGADDRLOW;                    lastOpCv = i*3+4;                    sendReadCommand(lastOpCv);                    return;                case READINGADDRLOW:                case READADDRHIGH:                    // set new state, send read, then done                    needRead[i] = READINGADDRHIGH;                    lastOpCv = i*3+5;                    sendReadCommand(lastOpCv);                    return;                case READINGADDRHIGH:                case READMODE:                    // set new state, send read, then done                    needRead[i] = READINGMODE;                    lastOpCv = i*3+3;                    sendReadCommand(lastOpCv);                    return;                case READINGMODE:                   // done                    needRead[i] = NONE;                    continue;   // find the next one instead!                default:                    log.error("found an unexpected state: "+needRead[1]+" "+i);                    return;                }            }        }        // no reads, so continue to check writes        for (int i=0; i<_numRows; i++) {            if (needWrite[i]!=NONE) {                // yes, needs read.  Find what kind                switch (needWrite[i]) {                case WRITEADDRLOW:                    // set new state, send read, then done                    needWrite[i] = WRITINGADDRLOW;                    lastOpCv = i*3+4;                    sendWriteCommand(lastOpCv, lowPart(addrFieldAsInt(i)));                    return;                case WRITINGADDRLOW:                case WRITEADDRHIGH:                    // set new state, send read, then done                    needWrite[i] = WRITINGADDRHIGH;                    lastOpCv = i*3+5;                    sendWriteCommand(lastOpCv, highPart(addrFieldAsInt(i)));                    return;                case WRITINGADDRHIGH:                case WRITEMODE:                    // set new state, send write, then done                    needWrite[i] = WRITINGMODE;                    lastOpCv = i*3+3;                    sendWriteCommand(lastOpCv, codeFromModeString((String)onMode[i]));                    return;                case WRITINGMODE:                   // done                    needWrite[i] = NONE;                    continue;   // find the next one instead!                default:                    log.error("found an unexpected state: "+needWrite[1]+" "+i);                    return;                }            }        }    }    /**     * Format and send a read command to the LocoIO device     * at the known unit address     * @param cv     */    protected void sendReadCommand(int cv) {        // format a read message        LocoNetMessage msg = new LocoNetMessage(16);        msg.setOpCode(0xE5);        msg.setElement(1, 0x10);  // 2nd part of op code        msg.setElement(2, 0x50);  // src address        msg.setElement(3, lowPart(unitAddress)&0x7F); // dst addr low        msg.setElement(4, highPart(unitAddress)&0x7F);  // dst addr high        msg.setElement(5, 0);   // pxct1        msg.setElement(6, 02);   // read command        msg.setElement(7, cv&0x7F);   // register        msg.setElement(8, 0);   //        msg.setElement(9, 0);   // data - not needed!        msg.setElement(10, 0x10);   // pxct2        // send message 		LnTrafficController.instance().sendLocoNetMessage(msg);    }    protected void sendWriteCommand(int cv, int data) {        // format a write message        LocoNetMessage msg = new LocoNetMessage(16);        msg.setOpCode(0xE5);        msg.setElement(1, 0x10);  // 2nd part of op code        msg.setElement(2, 0x50);  // src address        msg.setElement(3, lowPart(unitAddress)&0x7F); // dst addr low        msg.setElement(4, highPart(unitAddress)&0x7F);  // dst addr high        msg.setElement(5, 0);   // pxct1        msg.setElement(6, 1);   // write command        msg.setElement(7, cv&0x7F);   // register        msg.setElement(8, 0);   //        msg.setElement(9, data&0x7F);   // data        msg.setElement(10, 0x10);   // pxct2        // send message 		LnTrafficController.instance().sendLocoNetMessage(msg);    }	static org.apache.log4j.Category log = org.apache.log4j.Category.getInstance(LocoIOTableModel.class.getName());}