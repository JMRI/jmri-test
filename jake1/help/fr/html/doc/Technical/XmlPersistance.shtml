<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- $Id: XmlPersistance.shtml,v 1.8 2010/02/15 07:52:46 jacobsen Exp $ -->
<!-- Translated by Blorec Hervé le 2011-08-06--> 
<html lang="fr">
<!-- Copyright Bob Jacobsen 2004, 2007, 2008 -->
<head>
    <TITLE>
 	JMRI:  XML Persistance
    </TITLE>
    <META content="Bob Jacobsen" name=Author>
    <meta name="keywords" content="JMRI technical code xml persistance">

<!-- Style -->
  <META http-equiv=Content-Type content="text/html; charset= utf-8">
  <link rel="stylesheet" type="text/css" href="/css/default.css" media="screen">
  <link rel="stylesheet" type="text/css" href="/css/print.css" media="print">
  <link rel="icon" href="/images/jmri.ico" type="image/png">
  <link rel="home" title="Home" href="/">
<!-- /Style -->
</head>

<!--#include virtual="/Header" -->
<!--#include virtual="Sidebar" -->

	<div id="mainContent">

	    <H1>JMRI: Persistence XML </H1>


<P>
JMRI utilise XML pour la persistance des structures internes, en particulier lors du stockage
des préférences et des fichiers de panneau.

<P>
La persistance de XML se fait via un code écrit explicitement. Fondamentalement, certaines catégories
s'enregistrent auprès d'une instance de la "ConfigureManager". La mise en œuvre de l'un de ceux que nous
 avons est celui pour le chargement et le stockage des fichiers XML: jmri.configurexml.
ConfigXmlManager Quand il est temps pour stocker, on dit au ConfigureXmlManager de le faire.
Il va à travers les objets enregistrés et trouve la classe responsable de la persistance
du stockage de l'objet. Par exemple, abFoo classe aura la classe abconfigurexml.FooXml
située. Si cette catégorie est trouvée, elle est dite pour stocker l'objet Foo, et il ajoute un contenu Xml
dans un document JDOM pour le faire. Si ce n'est pas située, un message d'erreur est émis.
<P>
En charge, un fichier XML est lu par le gestionnaire. Chaque élément est examiné pour
une attribut "class". S'il est trouvé, cette classe est chargé et remis à l'élément
processus. Etc
<P>
Il est tout à fait hackers, et pas très proprement tenu . Il y a une bonne quantité de
duplication de code, mais peut-être parce qu'il vient d'un C + + de base et que
le développeur souhaite le garder pour des modèles et classes mixin. Mais ça marche!


<h3>ExEmple</h3>

Un LightManager connaît Lights.
<p>
Il ya beaucoup de classes concrètes implémentant l'interface Light:
<p>
<ul>
<li>jmri.jmrix.loconet.LnLight
<li>jmri.jmrix.cmri.serial.SerialLight
<li>jmri.jmrix.powerline.SerialLight
</ul>
Celles-ci ont leurs propres informations internes, ce qui n'est pas toujours le
cas.
<p>
Il ya aussi plusieurs classes concrètes LightManager pour les traiter
<p>
<ul>
<li>jmri.jmrix.loconet.LnLightManager
<li>jmri.jmrix.cmri.serial.SerialLightManager
<li>jmri.jmrix.powerline.SerialLightManager
</ul>

<p>
Chaque type de gestionnaire est stocké et chargé par l'intermédiaire d'une classe de persistance,
qui se trouve en consultant la classe A avec «XML » ajouté au nom, dans un
"configurexml" subpackage directe:
<ul>
<li>jmri.jmrix.loconet.configurexml.LnLightManagerXml
<li>jmri.jmrix.cmri.serial.configurexml.SerialLightManagerXml
<li>jmri.jmrix.powerline.configurexml.SerialLightManagerXml
</ul>

<p>Celles-ci ont leurs propres informations internes, ce qui n'est pas toujours le
cas.

Dans le cas des classes concrètes Light, le code de persistance du
gestionnaires directement stocke  et charge même directement les lumières individuelles. Ceci est
parce qu' (à ce jour) un gestionnaire donné a un seul type de Light (par exemple
LnLightManager n'a pas à se soucier de LnLight). Dans les cas où cela
n'est pas vrai, par exemple, SignalHeads qui ont plusieurs classes, ils
sont classes de persistance pour les objets individuels, en plus du gestionnaire.

<h3>Ajout d'informations à une Classe</h3>

Si vous souhaitez stocker plus de renseignements sur l'état, trouver la classe persistante
et ajouter du code pour créer et lire des attributs ou des éléments.
<p>
Peut-être la meilleure façon de faire est de créer un fichier de panneau de l'échantillon
de l'objet que vous souhaitez stocker dedans:

<p>
<pre>
  &lt;sensors class="jmri.jmrix.cmri.serial.configurexml.SerialSensorManagerXml" /&gt;
    &lt;sensor systemName="CS3001" /&gt;
  &lt;/sensor&gt;
  &lt;sensors class="jmri.managers.configurexml.InternalSensorManagerXml" /&gt;
   &lt;sensor systemName="IS21" /&gt;
  &lt;/sensors&gt;
  &lt;signalheads class="jmri.configurexml.AbstractSignalHeadManagerXml"&gt;
    &lt;signalhead class="jmri.configurexml.DoubleTurnoutSignalHeadXml" systemName="IH1P"&gt;
      &lt;turnout systemName="CT10" userName="1-bit pulsed green" /&gt;
      &lt;turnout systemName="CT2" userName="1-bit pulsed red" /&gt;
    &lt;/signalhead&gt;
  &lt;/signalheads&gt;
</pre>

<p>
Notez la «classe» attributs. Elle donne le nom pleinement qualifié
de la classe qui permet de charger ou stocker cet élément particulier. Dans le
cas de capteurs, nous voyons qu'il y a deux gestionnaires en service: un pour C/MRI, et
une pour les capteurs internes. Pour SignalHeads, il n'y a qu'un seul gérant,
jmri.configurexml.AbstractSignalHeadManager persisté par jmri.configurexml.AbstractSignalHeadManager,
mais chaque SignalHead notamment la mise en œuvre de classe a sa propre classe persistante.


<p>
 Par exemple pour ajouter des données sur un capteur, le jmri.jmrix.cmri.serial.configurexml.SerialSensorManagerXml
et les classes jmri.managers.configurexml.InternalSensorManagerXml devraient être
modifiées.

<p>
Notez que dans certains cas, il y a une relation d'héritage entre la persistance des classes qui peut aider. Par exemple, la classe LocoNet
<a href="http://jmri.sourceforge.net/JavaDoc/doc/jmri/jmrix/loconet/configurexml/LnSensorManagerXml.html"> LnSensorManagerXml </a>
hérite de
<a href="http://jmri.sourceforge.net/JavaDoc/doc/jmri/configurexml/AbstractTurnoutManagerConfigXML.html"> jmri.configurexml.AbstractSensorManagerConfigXML </a>, qui fait
presque tout le travail de stockage et de chargement de capteurs.

<p>
Si vous ajoutez des attributs ou des éléments nouveaux, n'oubliez pas de mettre à jour
la définition du format, voir ci-dessous..

<a id="schema">
<h2> Schéma de Gestion </h2>

JMRI contrôle la sémantique de XML utilisant le <a href="XmlSchema.shtml">Schema XML  </a>.

<p>
Par exemple, l'information mise en page est stockée dans des fichiers XML en tant qu'un élément 
de «schéma de configuration" , dont le contenu est alors défini par un
fichier de schéma. Ces fichiers sont conservés dans le répertoire
<a href="http://jmri.sf.net/xml/schema"> xml/schema </a>.

<!--#include virtual="/Footer" -->

	  </div><!-- closes #mainContent-->
	</div> <!-- closes #mBody-->
</body>
</html>

